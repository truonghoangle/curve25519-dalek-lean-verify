{"functions":
 [{"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}",
   "nested_children": [],
   "lines": "L230-L238",
   "lean_name": "curve25519_dalek.IdentityCurveModelsProjectivePoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.IdentityProjectivePoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::ProjectivePoint}",
   "nested_children": [],
   "lines": "L295-L302",
   "lean_name": "curve25519_dalek.IdentityMontgomeryProjectivePoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.IdentityProjectivePoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/mod.rs",
   "rust_name": "curve25519_dalek::backend::get_selected_backend",
   "nested_children": [],
   "lines": "L55-L75",
   "lean_name": "curve25519_dalek.backend.get_selected_backend",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec\n  (self : edwards.EdwardsPoint)\n  (other : backend.serial.curve_models.AffineNielsPoint)\n  (h_selfX_bounds : ∀ i, i < 5 → (self.X[i]!).val < 2 ^ 53)\n  (h_selfY_bounds : ∀ i, i < 5 → (self.Y[i]!).val < 2 ^ 53)\n  (h_selfZ_bounds : ∀ i, i < 5 → (self.Z[i]!).val < 2 ^ 53)\n  (h_selfT_bounds : ∀ i, i < 5 → (self.T[i]!).val < 2 ^ 53)\n  (h_otherYpX_bounds : ∀ i, i < 5 → (other.y_plus_x[i]!).val < 2 ^ 53)\n  (h_otherYmX_bounds : ∀ i, i < 5 → (other.y_minus_x[i]!).val < 2 ^ 53)\n  (h_otherXY2d_bounds : ∀ i, i < 5 → (other.xy2d[i]!).val < 2 ^ 53) :\n∃ c,\nadd self other = ok c ∧\nlet X := Field51_as_Nat self.X\nlet Y := Field51_as_Nat self.Y\nlet Z := Field51_as_Nat self.Z\nlet T := Field51_as_Nat self.T\nlet YpX := Field51_as_Nat other.y_plus_x\nlet YmX := Field51_as_Nat other.y_minus_x\nlet XY2D := Field51_as_Nat other.xy2d\nlet X' := Field51_as_Nat c.X\nlet Y' := Field51_as_Nat c.Y\nlet Z' := Field51_as_Nat c.Z\nlet T' := Field51_as_Nat c.T\n(X' + Y * YmX) % p = (((Y + X) * YpX) + X * YmX) % p ∧\n(Y' + X * YmX) % p = (((Y + X) * YpX) + Y  * YmX) % p ∧\nZ' % p = ((2 * Z) + (T * XY2D)) % p ∧\n(T' + (T * XY2D)) % p = (2 * Z) % p\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Add.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "nested_children": [],
   "lines": "L459-L473",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AddShared0EdwardsPointSharedAAffineNielsPointCompletedPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec\n    (self : curve25519_dalek.edwards.EdwardsPoint) (hself : self.IsValid)\n    (other : ProjectiveNielsPoint) (hother : other.IsValid) :\n    ∃ c, add self other = ok c ∧\n    c.IsValid ∧ c.toPoint = self.toPoint + other.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/CompletedPoint/Add.lean",
   "spec_docstring":
   "/-- Spec for `add`.\nThe theorem states that adding a valid EdwardsPoint with a valid ProjectiveNielsPoint:\n1. Always succeeds\n2. The output CompletedPoint is valid (bounds and algebraic properties)\n3. The output represents the sum of the input points\nThe mixed addition formulas implement elliptic curve point addition on twisted Edwards curves.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "nested_children": [],
   "lines": "L415-L430",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.AddShared0EdwardsPointSharedAProjectiveNielsPointCompletedPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::clone",
   "nested_children": [],
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CloneAffineNielsPoint.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::CompletedPoint}::clone",
   "nested_children": [],
   "lines": "L167-L167",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CloneCompletedPoint.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::clone::Clone for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::clone",
   "nested_children": [],
   "lines": "L204-L204",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CloneProjectiveNielsPoint.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_extended_spec (q : CompletedPoint)\n  (h_qX_bounds : ∀ i, i < 5 → (q.X[i]!).val < 2 ^ 54)\n  (h_qY_bounds : ∀ i, i < 5 → (q.Y[i]!).val < 2 ^ 54)\n  (h_qZ_bounds : ∀ i, i < 5 → (q.Z[i]!).val < 2 ^ 54)\n  (h_qT_bounds : ∀ i, i < 5 → (q.T[i]!).val < 2 ^ 54) :\n∃ e,\nas_extended q = ok e ∧\nlet X := Field51_as_Nat q.X\nlet Y := Field51_as_Nat q.Y\nlet Z := Field51_as_Nat q.Z\nlet T := Field51_as_Nat q.T\nlet X' := Field51_as_Nat e.X\nlet Y' := Field51_as_Nat e.Y\nlet Z' := Field51_as_Nat e.Z\nlet T' := Field51_as_Nat e.T\nX' % p = (X * T) % p ∧\nY' % p = (Y * Z) % p ∧\nZ' % p = (Z * T) % p ∧\nT' % p = (X * Y) % p\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/CompletedPoint/AsExtended.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.CompletedPoint.as_extended`**:\n- No panic (always returns successfully)\n- Given input CompletedPoint with coordinates (X, Y, Z, T), the output EdwardsPoint (X', Y', Z', T')\nsatisfies the conversion formulas modulo p:\n- X' ≡ X·T (mod p)\n- Y' ≡ Y·Z (mod p)\n- Z' ≡ Z·T (mod p)\n- T' ≡ X·Y (mod p)\nwhere p = 2^255 - 19\nThese formulas implement the conversion from completed ℙ¹ × ℙ¹ coordinates to extended\ntwisted Edwards ℙ³ coordinates.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::CompletedPoint}::as_extended",
   "nested_children": [],
   "lines": "L366-L373",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_projective_spec\n    (q : CompletedPoint) (hq_valid : q.IsValid) :\n    ∃ proj, as_projective q = ok proj ∧\n    proj.IsValid ∧ proj.toPoint = q.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/CompletedPoint/AsProjective.lean",
   "spec_docstring":
   "/--\nVerification of the `as_projective` function.\nThe theorem states that converting a valid CompletedPoint to ProjectivePoint:\n1. Always succeeds\n2. Produces a valid ProjectivePoint\n3. Preserves the represented affine point\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::CompletedPoint}::as_projective",
   "nested_children": [],
   "lines": "L354-L360",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_projective",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem conditional_assign_spec\n    (self other : backend.serial.curve_models.AffineNielsPoint)\n    (choice : subtle.Choice) :\n    ∃ result, conditional_assign self other choice = ok result ∧\n    (∀ i < 5, result.y_plus_x[i]!.val =\n      if choice.val = 1#u8 then other.y_plus_x[i]!.val else self.y_plus_x[i]!.val) ∧\n    (∀ i < 5, result.y_minus_x[i]!.val =\n      if choice.val = 1#u8 then other.y_minus_x[i]!.val else self.y_minus_x[i]!.val) ∧\n    (∀ i < 5, result.xy2d[i]!.val =\n      if choice.val = 1#u8 then other.xy2d[i]!.val else self.xy2d[i]!.val) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/ConditionalAssign.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ConditionallySelectableAffineNielsPoint.conditional_assign`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • an AffineNielsPoint `self` with coordinates (y_plus_x, y_minus_x, xy2d),\n  • an AffineNielsPoint `other` with coordinates (y_plus_x', y_minus_x', xy2d'),\n  • a Choice `choice`,\nthe output AffineNielsPoint computed by `conditional_assign self other choice` satisfies:\n- Each coordinate is conditionally selected: if choice is 1, output = other; if choice is 0, output = self\n- The operation is performed in constant time for all field elements\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::conditional_assign",
   "nested_children": [],
   "lines": "L323-L327",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ConditionallySelectableAffineNielsPoint.conditional_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : backend.serial.curve_models.AffineNielsPoint)\n    (choice : subtle.Choice) :\n    ∃ result, conditional_select a b choice = ok result ∧\n    (∀ i < 5, result.y_plus_x[i]!.val =\n      if choice.val = 1#u8 then b.y_plus_x[i]!.val else a.y_plus_x[i]!.val) ∧\n    (∀ i < 5, result.y_minus_x[i]!.val =\n      if choice.val = 1#u8 then b.y_minus_x[i]!.val else a.y_minus_x[i]!.val) ∧\n    (∀ i < 5, result.xy2d[i]!.val =\n      if choice.val = 1#u8 then b.xy2d[i]!.val else a.xy2d[i]!.val) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec and proof concerning `backend.serial.curve_models.AffineNielsPoint.conditional_select`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • AffineNielsPoint `a` with coordinates (y_plus_x, y_minus_x, xy2d),\n  • AffineNielsPoint `b` with coordinates (y_plus_x', y_minus_x', xy2d'),\n  • a Choice `choice`,\n  the output AffineNielsPoint has coordinates selected component-wise:\n  - If choice = 1, each coordinate equals the corresponding one of `b`\n  - If choice = 0, each coordinate equals the corresponding one of `a`\n  - The operation is constant-time (does not branch on choice)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::conditional_select",
   "nested_children": [],
   "lines": "L315-L321",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ConditionallySelectableAffineNielsPoint.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_select"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem conditional_assign_spec\n    (self other : backend.serial.curve_models.ProjectiveNielsPoint)\n    (choice : subtle.Choice) :\n    ∃ result, conditional_assign self other choice = ok result ∧\n    (∀ i < 5, result.Y_plus_X[i]!.val =\n      if choice.val = 1#u8 then other.Y_plus_X[i]!.val else self.Y_plus_X[i]!.val) ∧\n    (∀ i < 5, result.Y_minus_X[i]!.val =\n      if choice.val = 1#u8 then other.Y_minus_X[i]!.val else self.Y_minus_X[i]!.val) ∧\n    (∀ i < 5, result.Z[i]!.val =\n      if choice.val = 1#u8 then other.Z[i]!.val else self.Z[i]!.val) ∧\n    (∀ i < 5, result.T2d[i]!.val =\n      if choice.val = 1#u8 then other.T2d[i]!.val else self.T2d[i]!.val) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/ConditionalAssign.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ConditionallySelectableProjectiveNielsPoint.conditional_assign`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • a ProjectiveNielsPoint `self` with coordinates (Y_plus_X, Y_minus_X, Z, T2d),\n  • a ProjectiveNielsPoint `other` with coordinates (Y_plus_X', Y_minus_X', Z', T2d'),\n  • a Choice `choice`,\nthe output ProjectiveNielsPoint computed by `conditional_assign self other choice` satisfies:\n- Each coordinate is conditionally selected: if choice is 1, output = other; if choice is 0, output = self\n- The operation is performed in constant time for all field elements\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::conditional_assign",
   "nested_children": [],
   "lines": "L306-L311",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ConditionallySelectableProjectiveNielsPoint.conditional_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : backend.serial.curve_models.ProjectiveNielsPoint)\n    (choice : subtle.Choice) :\n    ∃ result, conditional_select a b choice = ok result ∧\n    (∀ i < 5, result.Y_plus_X[i]!.val =\n      if choice.val = 1#u8 then b.Y_plus_X[i]!.val else a.Y_plus_X[i]!.val) ∧\n    (∀ i < 5, result.Y_minus_X[i]!.val =\n      if choice.val = 1#u8 then b.Y_minus_X[i]!.val else a.Y_minus_X[i]!.val) ∧\n    (∀ i < 5, result.Z[i]!.val =\n      if choice.val = 1#u8 then b.Z[i]!.val else a.Z[i]!.val) ∧\n    (∀ i < 5, result.T2d[i]!.val =\n      if choice.val = 1#u8 then b.T2d[i]!.val else a.T2d[i]!.val) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec and proof concerning `backend.serial.curve_models.ProjectiveNielsPoint.conditional_select`**:\n- No panic (always returns successfully)\n- Given inputs:\n  • ProjectiveNielsPoint `a` with coordinates (Y_plus_X, Y_minus_X, Z, T2d),\n  • ProjectiveNielsPoint `b` with coordinates (Y_plus_X', Y_minus_X', Z', T2d'),\n  • a Choice `choice`,\n  the output ProjectiveNielsPoint has coordinates selected component-wise:\n  - If choice = 1, each coordinate equals the corresponding one of `b`\n  - If choice = 0, each coordinate equals the corresponding one of `a`\n  - The operation is constant-time (does not branch on choice)\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::conditional_select",
   "nested_children": [],
   "lines": "L297-L304",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ConditionallySelectableProjectiveNielsPoint.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_select"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::default::Default for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::default",
   "nested_children": [],
   "lines": "L268-L270",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.DefaultAffineNielsPoint.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.IdentityAffineNielsPoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::default::Default for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::default",
   "nested_children": [],
   "lines": "L252-L254",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.DefaultProjectiveNielsPoint.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.IdentityProjectiveNielsPoint.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem assert_receiver_is_total_eq_spec\n    (self : backend.serial.curve_models.AffineNielsPoint) :\n    ∃ result, assert_receiver_is_total_eq self = ok result ∧ result = () := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/AssertReceiverIsTotalEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `EqAffineNielsPoint.assert_receiver_is_total_eq`**:\n- No panic (always returns successfully)\n- The result is `()`\n- This is the `Eq`-trait totality assertion for `AffineNielsPoint`\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::cmp::Eq for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::assert_receiver_is_total_eq",
   "nested_children": [],
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.EqAffineNielsPoint.assert_receiver_is_total_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::identity",
   "nested_children": [],
   "lines": "L258-L264",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.IdentityAffineNielsPoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::identity",
   "nested_children": [],
   "lines": "L241-L248",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.IdentityProjectiveNielsPoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::identity",
   "nested_children": [],
   "lines": "L231-L237",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.IdentityProjectivePoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem neg_spec\n    (self : backend.serial.curve_models.AffineNielsPoint)\n    (self_bound : ∀ i < 5, ↑self.xy2d[i]!.val < 2 ^ 54) :\n    ∃ result, neg self = ok result ∧\n    result.y_plus_x = self.y_minus_x ∧\n    result.y_minus_x = self.y_plus_x ∧\n    (Field51_as_Nat self.xy2d + Field51_as_Nat result.xy2d) % p = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Neg.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for &0 (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint)}::neg",
   "nested_children": [],
   "lines": "L517-L523",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.NegShared0AffineNielsPointAffineNielsPoint.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.NegShared0FieldElement51FieldElement51.neg"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem neg_spec\n    (self : ProjectiveNielsPoint)\n    (self_bound : ∀ i, i < 5 → (self.T2d[i]!).val < 2 ^ 54) :\n    ∃ result, neg self = ok result ∧\n    result.Y_plus_X = self.Y_minus_X ∧\n    result.Y_minus_X = self.Y_plus_X ∧\n    result.Z = self.Z ∧\n    (Field51_as_Nat self.T2d + Field51_as_Nat result.T2d) % p = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/Neg.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ProjectiveNielsPoint.neg`**:\n- No panic (always returns successfully)\n- Given input:\n  • a ProjectiveNielsPoint `self` with coordinates (Y_plus_X, Y_minus_X, Z, T2d),\nthe output ProjectiveNielsPoint computed by `neg self` has coordinates\n(Y_plus_X', Y_minus_X', Z', T2d') where:\n- Y_plus_X' = Y_minus_X (the coordinates are swapped)\n- Y_minus_X' = Y_plus_X (the coordinates are swapped)\n- Z' = Z (the Z coordinate is unchanged)\n- T2d' ≡ -T2d (mod p) (the T2d coordinate is negated modulo p)\n\nwhere p = 2^255 - 19.\n\nThis implements the negation of a point in projective Niels coordinates.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Neg<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint> for &0 (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint)}::neg",
   "nested_children": [],
   "lines": "L504-L511",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.NegShared0ProjectiveNielsPointProjectiveNielsPoint.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.NegShared0FieldElement51FieldElement51.neg"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem eq_spec\n    (self other : backend.serial.curve_models.AffineNielsPoint) :\n    ∃ b, eq self other = ok b ∧\n    (b = true ↔\n      field.PartialEqFieldElement51FieldElement51.eq self.y_plus_x other.y_plus_x = ok true ∧\n      field.PartialEqFieldElement51FieldElement51.eq self.y_minus_x other.y_minus_x = ok true ∧\n      field.PartialEqFieldElement51FieldElement51.eq self.xy2d other.xy2d = ok true) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Eq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `PartialEqAffineNielsPointAffineNielsPoint.eq`**:\n- No panic (always returns successfully)\n- Returns true iff all three coordinate comparisons return true\n- Short-circuits to false as soon as a comparison fails\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::cmp::PartialEq<curve25519_dalek::backend::serial::curve_models::AffineNielsPoint> for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::eq",
   "nested_children": [],
   "lines": "L182-L182",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.PartialEqAffineNielsPointAffineNielsPoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.field.PartialEqFieldElement51FieldElement51.eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_extended_spec (q : ProjectivePoint)\n  (h_qX_bounds : ∀ i, i < 5 → (q.X[i]!).val < 2 ^ 54)\n  (h_qY_bounds : ∀ i, i < 5 → (q.Y[i]!).val < 2 ^ 54)\n  (h_qZ_bounds : ∀ i, i < 5 → (q.Z[i]!).val < 2 ^ 54) :\n∃ e,\nas_extended q = ok e ∧\nlet X := Field51_as_Nat q.X\nlet Y := Field51_as_Nat q.Y\nlet Z := Field51_as_Nat q.Z\nlet X' := Field51_as_Nat e.X\nlet Y' := Field51_as_Nat e.Y\nlet Z' := Field51_as_Nat e.Z\nlet T' := Field51_as_Nat e.T\nX' % p = (X * Z) % p ∧\nY' % p = (Y * Z) % p ∧\nZ' % p = (Z^2) % p ∧\nT' % p = (X * Y) % p\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectivePoint/AsExtended.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.curve_models.ProjectivePoint.as_extended`**:\n- No panic (always returns successfully)\n- Given input ProjectivePoint with coordinates (X, Y, Z), the output EdwardsPoint (X', Y', Z', T')\nsatisfies the conversion formulas modulo p:\n- X' ≡ X·Z (mod p)\n- Y' ≡ Y·Z (mod p)\n- Z' ≡ Z² (mod p)\n- T' ≡ X·Y (mod p)\nwhere p = 2^255 - 19\nThese formulas implement the (division-free) conversion from projective ℙ² coordinates to extended\ntwisted Edwards ℙ³ coordinates.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::as_extended",
   "nested_children": [],
   "lines": "L339-L346",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.as_extended",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem double_spec\n    (q : ProjectivePoint) (hq_valid : q.IsValid) :\n    ∃ c, ProjectivePoint.double q = ok c ∧\n    c.IsValid ∧ c.toPoint = q.toPoint + q.toPoint := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectivePoint/Double.lean",
   "spec_docstring":
   "/--\nVerification of the `double` function.\nThe theorem states that the Rust implementation of point doubling corresponds\nexactly to the mathematical addition of the point to itself (`q + q`) on the Edwards curve.\n-/",
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::double",
   "nested_children": [],
   "lines": "L382-L398",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec\n  (self : edwards.EdwardsPoint)\n  (other : backend.serial.curve_models.AffineNielsPoint)\n  (h_selfX_bounds : ∀ i, i < 5 → (self.X[i]!).val < 2 ^ 53)\n  (h_selfY_bounds : ∀ i, i < 5 → (self.Y[i]!).val < 2 ^ 53)\n  (h_selfZ_bounds : ∀ i, i < 5 → (self.Z[i]!).val < 2 ^ 53)\n  (h_selfT_bounds : ∀ i, i < 5 → (self.T[i]!).val < 2 ^ 53)\n  (h_otherYpX_bounds : ∀ i, i < 5 → (other.y_plus_x[i]!).val < 2 ^ 53)\n  (h_otherYmX_bounds : ∀ i, i < 5 → (other.y_minus_x[i]!).val < 2 ^ 53)\n  (h_otherXY2d_bounds : ∀ i, i < 5 → (other.xy2d[i]!).val < 2 ^ 53) :\n∃ c, sub self other = ok c ∧\nlet X := Field51_as_Nat self.X\nlet Y := Field51_as_Nat self.Y\nlet Z := Field51_as_Nat self.Z\nlet T := Field51_as_Nat self.T\nlet YpX := Field51_as_Nat other.y_plus_x\nlet YmX := Field51_as_Nat other.y_minus_x\nlet XY2D := Field51_as_Nat other.xy2d\nlet X' := Field51_as_Nat c.X\nlet Y' := Field51_as_Nat c.Y\nlet Z' := Field51_as_Nat c.Z\nlet T' := Field51_as_Nat c.T\n(X' + Y * YpX) % p = (((Y + X) * YmX) + X * YpX) % p ∧\n(Y' + X * YpX) % p = (((Y + X) * YmX) + Y  * YpX) % p ∧\n(Z' + (T * XY2D)) % p = (2 * Z) % p ∧\nT' % p = ((2 * Z) + (T * XY2D)) % p\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/AffineNielsPoint/Sub.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::curve_models::AffineNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::sub",
   "nested_children": [],
   "lines": "L480-L494",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.SubShared0EdwardsPointSharedAAffineNielsPointCompletedPoint.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec\n  (self : edwards.EdwardsPoint)\n  (other : backend.serial.curve_models.ProjectiveNielsPoint)\n  (h_selfX_bounds : ∀ i, i < 5 → (self.X[i]!).val < 2 ^ 53)\n  (h_selfY_bounds : ∀ i, i < 5 → (self.Y[i]!).val < 2 ^ 53)\n  (h_selfZ_bounds : ∀ i, i < 5 → (self.Z[i]!).val < 2 ^ 53)\n  (h_selfT_bounds : ∀ i, i < 5 → (self.T[i]!).val < 2 ^ 53)\n  (h_otherYpX_bounds : ∀ i, i < 5 → (other.Y_plus_X[i]!).val < 2 ^ 53)\n  (h_otherYmX_bounds : ∀ i, i < 5 → (other.Y_minus_X[i]!).val < 2 ^ 53)\n  (h_otherZ_bounds : ∀ i, i < 5 → (other.Z[i]!).val < 2 ^ 53)\n  (h_otherT2d_bounds : ∀ i, i < 5 → (other.T2d[i]!).val < 2 ^ 53) :\n∃ c, sub self other = ok c ∧\nlet X := Field51_as_Nat self.X\nlet Y := Field51_as_Nat self.Y\nlet Z := Field51_as_Nat self.Z\nlet T := Field51_as_Nat self.T\nlet YpX := Field51_as_Nat other.Y_plus_X\nlet YmX := Field51_as_Nat other.Y_minus_X\nlet Z₀ := Field51_as_Nat other.Z\nlet T2d := Field51_as_Nat other.T2d\nlet X' := Field51_as_Nat c.X\nlet Y' := Field51_as_Nat c.Y\nlet Z' := Field51_as_Nat c.Z\nlet T' := Field51_as_Nat c.T\n(X' + Y * YpX) % p = (((Y + X) * YmX) + X * YpX) % p ∧\n(Y' + X * YpX) % p = (((Y + X) * YmX) + Y  * YpX) % p ∧\n(Z' + (T * T2d) )% p = (2 * Z * Z₀)  % p ∧\nT' % p = ((2 * Z * Z₀) + (T * T2d)) % p\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/CurveModels/ProjectiveNielsPoint/Sub.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint), curve25519_dalek::backend::serial::curve_models::CompletedPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::sub",
   "nested_children": [],
   "lines": "L437-L452",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.SubShared0EdwardsPointSharedAProjectiveNielsPointCompletedPoint.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::ValidityCheck for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}::is_valid",
   "nested_children": [],
   "lines": "L278-L289",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ValidityCheckProjectivePoint.is_valid",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.field.PartialEqFieldElement51FieldElement51.eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}::zeroize",
   "nested_children": [],
   "lines": "L192-L196",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ZeroizeAffineNielsPoint.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ZeroizeFieldElement51.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}::zeroize",
   "nested_children": [],
   "lines": "L215-L220",
   "lean_name":
   "curve25519_dalek.backend.serial.curve_models.ZeroizeProjectiveNielsPoint.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ZeroizeFieldElement51.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::scalar_mul::variable_base::mul",
   "nested_children": [],
   "lines": "L11-L51",
   "lean_name": "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.window.FromLookupTableProjectiveNielsPointSharedAEdwardsPoint.from",
    "curve25519_dalek.scalar.Scalar.as_radix_16",
    "curve25519_dalek.edwards.IdentityEdwardsPoint.identity",
    "curve25519_dalek.window.LookupTable.select",
    "curve25519_dalek.traits.IdentityProjectiveNielsPoint",
    "curve25519_dalek.backend.serial.curve_models.AddShared0EdwardsPointSharedAProjectiveNielsPointCompletedPoint.add",
    "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul_loop",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::scalar_mul::variable_base::mul",
   "nested_children": [],
   "lines": "L36-L49",
   "lean_name":
   "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_projective",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended",
    "curve25519_dalek.window.LookupTable.select",
    "curve25519_dalek.traits.IdentityProjectiveNielsPoint",
    "curve25519_dalek.backend.serial.curve_models.AddShared0EdwardsPointSharedAProjectiveNielsPointCompletedPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::APLUS2_OVER_FOUR",
   "nested_children": [],
   "lines": "L108-L109",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::APLUS2_OVER_FOUR",
   "nested_children": [],
   "lines": "L108-L109",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ED25519_BASEPOINT_POINT",
   "nested_children": [],
   "lines": "L161-L184",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ED25519_BASEPOINT_POINT",
   "nested_children": [],
   "lines": "L161-L184",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem EDWARDS_D_spec : Field51_as_Nat EDWARDS_D = d := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EDWARDS_D.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EDWARDS_D`**:\n- The value of constants.EDWARDS_D when converted to a natural number equals d\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D",
   "nested_children": [],
   "lines": "L45-L51",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_body"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem EDWARDS_D2_spec : Field51_as_Nat EDWARDS_D2 =  (2 * d) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EDWARDS_D2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EDWARDS_D2`**:\n- The value of constants.EDWARDS_D2 when converted to a natural number equals\n  the canonical (reduced) representation of 2*d (mod p) in [0, p-1].\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D2",
   "nested_children": [],
   "lines": "L54-L60",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D2",
   "nested_children": [],
   "lines": "L54-L60",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem EDWARDS_D_MINUS_ONE_SQUARED_spec : Field51_as_Nat EDWARDS_D_MINUS_ONE_SQUARED = (d - 1)^2 % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/EDWARDS_D_MINUS_ONE_SQUARED.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED`**:\n- The value of constants.EDWARDS_D_MINUS_ONE_SQUARED when converted to a natural number equals\n  the canonical (reduced) representation of (d - 1)² (mod p) in [0, p-1].\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D_MINUS_ONE_SQUARED",
   "nested_children": [],
   "lines": "L72-L78",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D_MINUS_ONE_SQUARED",
   "nested_children": [],
   "lines": "L72-L78",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::EDWARDS_D",
   "nested_children": [],
   "lines": "L45-L51",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION",
   "nested_children": [],
   "lines": "L194-L194",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION_INNER_DOC_HIDDEN",
   "nested_children": [],
   "lines": "L198-L337",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION_INNER_DOC_HIDDEN",
   "nested_children": [],
   "lines": "L198-L337",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::EIGHT_TORSION",
   "nested_children": [],
   "lines": "L194-L194",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION_INNER_DOC_HIDDEN"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem INVSQRT_A_MINUS_D_spec :\n    (Field51_as_Nat INVSQRT_A_MINUS_D)^2 * (a - d) % p = 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/INVSQRT_A_MINUS_D.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.INVSQRT_A_MINUS_D`**:\n- Field51_as_Nat(constants.INVSQRT_A_MINUS_D)^2 * (a - d) ≡ 1 (mod p), which is equivalent\n  to Field51_as_Nat(constants.INVSQRT_A_MINUS_D) ≡ 1/sqrt(a-d) (mod p).\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::INVSQRT_A_MINUS_D",
   "nested_children": [],
   "lines": "L90-L96",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::INVSQRT_A_MINUS_D",
   "nested_children": [],
   "lines": "L90-L96",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem L_spec : Scalar52_as_Nat L = _root_.L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/L.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.L`**:\n- The value of constants.L when converted to a natural number equals L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::L",
   "nested_children": [],
   "lines": "L127-L133",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.L",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.backend.serial.u64.constants.L_body"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem LFACTOR_spec :\n    (_root_.L * LFACTOR + 1) % (2^52) = 0 ∧\n    0 ≤ LFACTOR.val ∧\n    LFACTOR.val < 2^52 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/LFACTOR.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.LFACTOR`**:\n- The value of LFACTOR satisfies: L * LFACTOR ≡ -1 (mod 2^52)\n- LFACTOR is in the range [0, 2^52 - 1]\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::LFACTOR",
   "nested_children": [],
   "lines": "L136-L136",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.LFACTOR",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.LFACTOR_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::LFACTOR",
   "nested_children": [],
   "lines": "L136-L136",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.LFACTOR_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::L",
   "nested_children": [],
   "lines": "L127-L133",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.L_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MINUS_ONE_spec : Field51_as_Nat MINUS_ONE = p - 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/MINUS_ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.MINUS_ONE`**:\n- The value of constants.MINUS_ONE, when converted to a natural number, equals p − 1\n  (the canonical representative of −1 modulo p in [0, p-1]).\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::MINUS_ONE",
   "nested_children": [],
   "lines": "L26-L32",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.MINUS_ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.MINUS_ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::MINUS_ONE",
   "nested_children": [],
   "lines": "L26-L32",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.MINUS_ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MONTGOMERY_A_spec : Field51_as_Nat MONTGOMERY_A = 486662 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/MONTGOMERY_A.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.MONTGOMERY_A`**:\n- The value of constants.MONTGOMERY_A when converted to a natural number equals 486662\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A",
   "nested_children": [],
   "lines": "L114-L114",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_body"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MONTGOMERY_A_NEG_spec :\n    Field51_as_Nat MONTGOMERY_A_NEG + Field51_as_Nat MONTGOMERY_A= p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/MONTGOMERY_A_NEG.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.MONTGOMERY_A_NEG`**:\n- The value of constants.MONTGOMERY_A_NEG when converted to a natural number equals\n  p - 486662 = 57896044618658097711785492504343953926634992332820282019728792003956564333287\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A_NEG",
   "nested_children": [],
   "lines": "L118-L124",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A_NEG",
   "nested_children": [],
   "lines": "L118-L124",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::MONTGOMERY_A",
   "nested_children": [],
   "lines": "L114-L114",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ONE_MINUS_EDWARDS_D_SQUARED_spec : Field51_as_Nat ONE_MINUS_EDWARDS_D_SQUARED = (1 + p - (d^2 % p)) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/ONE_MINUS_EDWARDS_D_SQUARED.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED`**:\n- The value of constants.ONE_MINUS_EDWARDS_D_SQUARED when converted to a natural number equals\n  the canonical (reduced) representation of (1 - d²) (mod p) in [0, p-1].\n  Note: the extra \" + p\" in the spec theorem is to avoided hitting 0 in the truncated subtraction\n  implemented by Lean.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ONE_MINUS_EDWARDS_D_SQUARED",
   "nested_children": [],
   "lines": "L63-L69",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::ONE_MINUS_EDWARDS_D_SQUARED",
   "nested_children": [],
   "lines": "L63-L69",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem R_spec : Scalar52_as_Nat R % _root_.L = _root_.R % _root_.L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/R.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.R`**:\n- The value of constants.R when converted to a natural number is congruent to R modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::R",
   "nested_children": [],
   "lines": "L139-L145",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.R",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.backend.serial.u64.constants.R_body"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem RR_spec : Scalar52_as_Nat RR % _root_.L = _root_.R ^ 2 % _root_.L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/RR.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.RR`**:\n- The value of constants.RR when converted to a natural number is congruent to R² modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::RR",
   "nested_children": [],
   "lines": "L148-L154",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.RR",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.backend.serial.u64.constants.RR_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::RR",
   "nested_children": [],
   "lines": "L148-L154",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.RR_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::R",
   "nested_children": [],
   "lines": "L139-L145",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.R_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem SQRT_AD_MINUS_ONE_spec :\n    (Field51_as_Nat SQRT_AD_MINUS_ONE)^2 % p = (a * d - 1) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/SQRT_AD_MINUS_ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.SQRT_AD_MINUS_ONE`**:\n- Field51_as_Nat(constants.SQRT_AD_MINUS_ONE) is a square root of (a*d - 1) modulo p, i.e.\n  `(Field51_as_Nat constants.SQRT_AD_MINUS_ONE)^2 ≡ (a*d - 1) (mod p)`.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::SQRT_AD_MINUS_ONE",
   "nested_children": [],
   "lines": "L81-L87",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::constants::SQRT_AD_MINUS_ONE",
   "nested_children": [],
   "lines": "L81-L87",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem SQRT_M1_spec :\n    (Field51_as_Nat SQRT_M1)^2 % p = p - 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Constants/SQRT_M1.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.constants.SQRT_M1`**:\n- Field51_as_Nat(constants.SQRT_M1) ≡ sqrt(-1) (mod p), which is equivalent to\n  Field51_as_Nat(constants.SQRT_M1)^2 ≡ p - 1 (mod p).\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::SQRT_M1",
   "nested_children": [],
   "lines": "L99-L105",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.SQRT_M1_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/constants.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::constants::SQRT_M1",
   "nested_children": [],
   "lines": "L99-L105",
   "lean_name": "curve25519_dalek.backend.serial.u64.constants.SQRT_M1_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_assign_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 53)\n    (hb : ∀ i < 5, b[i]!.val < 2 ^ 53) :\n    ∃ result, add_assign a b = ok result ∧\n    (∀ i < 5, (result[i]!).val = (a[i]!).val + (b[i]!).val) ∧\n    (∀ i < 5, result[i]!.val < 2 ^ 54) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/AddAssign.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign`**:\n- Does not overflow when limb sums don't exceed `U64.max`\n- Returns a field element where each limb is the sum of corresponding input limbs\n- Input bounds: both inputs have limbs < 2^53\n- Output bounds: output has limbs < 2^54 -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::AddAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::add_assign",
   "nested_children": [],
   "lines": "L59-L65",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_assign_loop_spec (a b : Array U64 5#usize) (i : Usize) (hi : i.val ≤ 5)\n    (hab : ∀ j < 5, i.val ≤ j → a[j]!.val + b[j]!.val ≤ U64.max) :\n    ∃ a', add_assign_loop a b i = ok a' ∧\n    (∀ j < 5, i.val ≤ j → a'[j]!.val = a[j]!.val + b[j]!.val) ∧\n    (∀ j < 5, j < i.val → a'[j]! = a[j]!) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/AddAssign.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign_loop`**:\n- Iterates through limbs adding `b[i]` to `a[i]`\n- Does not overflow if limb sums don't exceed `U64.max`. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::AddAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::add_assign",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign_loop._unsafe_rec",
    "curve25519_dalek.backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign_loop.mutual"],
   "lines": "L61-L64",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 53) (hb : ∀ i < 5, b[i]!.val < 2 ^ 53) :\n    ∃ result, add a b = ok result ∧\n    (∀ i < 5, result[i]!.val = a[i]!.val + b[i]!.val) ∧\n    (∀ i < 5, result[i]!.val < 2^54) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Add.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add`**:\n- Does not overflow when limb sums don't exceed U64.max\n- Returns a field element where each limb is the sum of corresponding input limbs\n- This is element-wise addition, not modular field addition (use reduce for that)\n- Input bounds: both inputs have limbs < 2^53\n- Output bounds: output has limbs < 2^54\n- Simply wraps add_assign -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Add<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::add",
   "nested_children": [],
   "lines": "L70-L74",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddAssignFieldElement51SharedAFieldElement51.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::clone::Clone for curve25519_dalek::backend::serial::u64::field::FieldElement51}::clone",
   "nested_children": [],
   "lines": "L42-L42",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.CloneFieldElement51.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_assign_spec\n    (self other : backend.serial.u64.field.FieldElement51)\n    (choice : subtle.Choice) :\n    ∃ res,\n      backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign\n        self other choice = ok res ∧\n      (∀ i < 5,\n        res[i]! = (if choice.val = 1#u8 then other[i]! else self[i]!)) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ConditionalAssign.lean",
   "spec_docstring":
   "/--\n**Spec for `backend.serial.u64.field.FieldElement51.conditional_assign`**:\n- No panic (always returns successfully)\n- For each limb i, the result limb equals `other[i]` when `choice = 1`,\n  and equals `self[i]` when `choice = 0` (constant-time conditional select)\n- Consequently, when `choice = Choice.one`, the whole result equals `other`;\n  when `choice = Choice.zero`, the result equals `self`.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}::conditional_assign",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign.match_1"],
   "lines": "L250-L256",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_select_spec\n    (a b : backend.serial.u64.field.FieldElement51)\n    (choice : subtle.Choice) :\n    ∃ res,\n      backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_select\n        a b choice = ok res ∧\n      (∀ i < 5,\n        res[i]! = (if choice.val = 1#u8 then b[i]! else a[i]!)) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ConditionalSelect.lean",
   "spec_docstring":
   "/--\n**Spec for `backend.serial.u64.field.FieldElement51.conditional_select`**:\n- No panic (always returns successfully)\n- For each limb i, the result limb equals `b[i]` when `choice = 1`,\n  and equals `a[i]` when `choice = 0` (constant-time conditional select)\n- Consequently, when `choice = Choice.one`, the whole result equals `b`;\n  when `choice = Choice.zero`, the result equals `a`.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}::conditional_select",
   "nested_children": [],
   "lines": "L228-L240",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{subtle::ConditionallySelectable for curve25519_dalek::backend::serial::u64::field::FieldElement51}::conditional_swap",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_swap.match_1"],
   "lines": "L242-L248",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_swap",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem MINUS_ONE_spec : Field51_as_Nat MINUS_ONE = p - 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/MINUS_ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.MINUS_ONE`**:\n- The constant, when converted to a natural number, equals 2^255 - 20 (i.e., p - 1)\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::MINUS_ONE",
   "nested_children": [],
   "lines": "L269-L275",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::MINUS_ONE",
   "nested_children": [],
   "lines": "L269-L275",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ONE_spec : Field51_as_Nat ONE = 1 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ONE.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.ONE`**:\n- The constant, when converted to a natural number, equals 1\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ONE",
   "nested_children": [],
   "lines": "L267-L267",
   "lean_name": "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ONE",
   "nested_children": [],
   "lines": "L267-L267",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ZERO_spec : Field51_as_Nat ZERO = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ZERO.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.ZERO`**:\n- The constant, when converted to a natural number, equals 0\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ZERO",
   "nested_children": [],
   "lines": "L265-L265",
   "lean_name": "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::ZERO",
   "nested_children": [],
   "lines": "L265-L265",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (self : backend.serial.u64.field.FieldElement51) :\n    ∃ result, as_bytes self = ok result ∧\n    U8x32_as_Nat result ≡ Field51_as_Nat self [MOD p] ∧\n    U8x32_as_Nat result < p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.FieldElement51.as_bytes`**:\n\nFunction was deprecated since 4.1.4 and renamed to `to_bytes`. Simply calls the other function. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::as_bytes",
   "nested_children": [],
   "lines": "L369-L371",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_spec (bytes : Array U8 32#usize) :\n    ∃ result, from_bytes bytes = ok result ∧\n    Field51_as_Nat result ≡ (U8x32_as_Nat bytes % 2^255) [MOD p] := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/FromBytes.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::from_bytes",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes.load8_at"],
   "lines": "L340-L365",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_limbs_spec (a : Array U64 5#usize) :\n    ∃ r, from_limbs a = ok r ∧\n    r = a ∧ Field51_as_Nat r = Field51_as_Nat a := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/FromLimbs.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.from_limbs`**:\n- No panic (always returns successfully)\n- The result is identical to the input limbs array\n- The natural number representation of the result equals that of the input\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::from_limbs",
   "nested_children": [],
   "lines": "L260-L262",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_limbs",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem negate_spec (r : FieldElement51) (h : ∀ i < 5, r[i]!.val < 2 ^ 54) :\n    ∃ r_inv, negate r = ok r_inv ∧\n    (Field51_as_Nat r + Field51_as_Nat r_inv) % p = 0 ∧\n    (∀ i < 5, r_inv[i]!.val ≤ 2^51 + (2^13 - 1) * 19) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Negate.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.negate`**:\n- No panic (always returns successfully)\n- The result r_inv represents the additive inverse of the input r in 𝔽_p, i.e.,\n  Field51_as_Nat(r) + Field51_as_Nat(r_inv) ≡ 0 (mod p)\n- All the limbs of the result are small, ≤ 2^(51 + ε)\n- Requires that input limbs of r are bounded to avoid underflow:\n  - Limb 0 must be ≤ 36028797018963664\n  - Limbs 1-4 must be ≤ 36028797018963952\n  To make the theorem more readable we use a single bound for all limbs. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::negate",
   "nested_children": [],
   "lines": "L278-L288",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.negate",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\n\ntheorem pow2k_spec (a : Array U64 5#usize) (k : U32) (hk : 0 < k.val)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    ∃ r, pow2k a k = ok r ∧\n    Field51_as_Nat r ≡ (Field51_as_Nat a)^(2^k.val) [MOD p] ∧\n    (∀ i < 5, r[i]!.val < 2 ^ 52)\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Pow2K.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.pow2k`**:\n- No panic (always returns successfully) when k > 0\n- The result, when converted to a natural number, is congruent to the input raised to the (2^k)-th power modulo p\n- Input bounds: each limb < 2^54\n- Output bounds: each limb < 2^52\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.m",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.LOW_51_BIT_MASK",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k.LOW_51_BIT_MASK_body"],
   "lines": "L462-L567",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem pow2k_loop_spec (k : ℕ) (k' : U32) (a : Array U64 5#usize)\n    (hk : 0 < k) (eqk : k'.val = k)\n    (h_bounds : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    ∃ r, pow2k_loop k' a = ok r ∧\n    Field51_as_Nat r ≡ (Field51_as_Nat a)^(2^k) [MOD p] ∧\n    (∀ i < 5, r[i]!.val < 2 ^ 52) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Pow2K.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow2k",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k_loop.match_1",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k_loop._unsafe_rec"],
   "lines": "L488-L500",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem reduce_spec (limbs : Array U64 5#usize) :\n    ∃ result, reduce limbs = ok result ∧\n    (∀ i < 5, result[i]!.val ≤ 2^51 + (2^13 - 1) * 19) ∧\n    Field51_as_Nat limbs ≡ Field51_as_Nat result [MOD p] := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Reduce.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.reduce`**:\n- Does not overflow and hence returns a result\n- All the limbs of the result are small, ≤ 2^(51 + ε)\n- The result is equal to the input mod p. -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::reduce",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK_body",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce.LOW_51_BIT_MASK"],
   "lines": "L292-L325",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square_spec (a : Array U64 5#usize) (ha : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    ∃ r, square a = ok r ∧\n    Field51_as_Nat r ≡ (Field51_as_Nat a)^2 [MOD p] ∧ (∀ i < 5, r[i]!.val < 2 ^ 52) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Square.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.square`**:\n- No panic (always returns successfully)\n- The result, when converted to a natural number, is congruent to the square of the input modulo p\n- Input bounds: each limb < 2^54\n- Output bounds: each limb < 2^52\n- Note: this implements the `pow2k` function with k=1\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::square",
   "nested_children": [],
   "lines": "L570-L572",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square2_spec (a : Array U64 5#usize) (h_bounds : ∀ i < 5, a[i]!.val < 2 ^ 54) :\n    ∃ r, square2 a = ok r ∧\n    Field51_as_Nat r % p = (2 * (Field51_as_Nat a)^2) % p ∧ (∀ i < 5, r[i]!.val < 2 ^ 53) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Square2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.square2`**:\n- No panic (always returns successfully)\n- The result, when converted to a natural number, is congruent to twice the square of the input modulo p\n- Input bounds: each limb < 2^54\n- Output bounds: each limb < 2^53\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::square2",
   "nested_children": [],
   "lines": "L575-L584",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square2_loop_spec (square : Array U64 5#usize) (i : Usize) (hi : i.val ≤ 5)\n    (h_no_overflow : ∀ j < 5, i.val ≤ j → square[j]!.val * 2 ≤ U64.max) :\n    ∃ r, square2_loop square i = ok r ∧\n    (∀ j < 5, i.val ≤ j → r[j]!.val = square[j]!.val * 2) ∧\n    (∀ j < 5, j < i.val → r[j]! = square[j]!) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Square2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning the loop in `backend.serial.u64.field.FieldElement51.square2`**:\n- No panic when i ≤ 5\n- Doubles each limb from index i onwards\n- Leaves limbs before index i unchanged\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::square2",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square2_loop._unsafe_rec"],
   "lines": "L578-L581",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.square2_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (self : backend.serial.u64.field.FieldElement51) :\n    ∃ result, to_bytes self = ok result ∧\n    U8x32_as_Nat result ≡ Field51_as_Nat self [MOD p] ∧\n    U8x32_as_Nat result < p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.FieldElement51.to_bytes`**:\n\nThis function converts a field element to its canonical 32-byte little-endian representation.\nThe implementation performs reduction modulo p = 2^255-19 to ensure the result is in\ncanonical form.\n\nThe algorithm:\n1. Reduces the field element using `reduce` to ensure all limbs are within bounds\n2. Performs a final conditional reduction to ensure the result is < p\n3. Packs the 5 limbs (each 51 bits) into 32 bytes in little-endian format\n\nSpecification:\n- The function succeeds (no panic)\n- The natural number interpretation of the byte array is congruent to the field element value modulo p\n- The byte array represents the unique canonical form (0 ≤ value < p)\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::to_bytes",
   "nested_children": [],
   "lines": "L376-L458",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::MulAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::mul_assign",
   "nested_children": [],
   "lines": "L107-L110",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.MulAssignFieldElement51SharedAFieldElement51.mul_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_spec (lhs rhs : Array U64 5#usize)\n    (hlhs : ∀ i < 5, lhs[i]!.val < 2 ^ 54) (hrhs : ∀ i < 5, rhs[i]!.val < 2 ^ 54) :\n    ∃ r, mul lhs rhs = ok r ∧\n    Field51_as_Nat r ≡ (Field51_as_Nat lhs) * (Field51_as_Nat rhs) [MOD p] ∧\n    (∀ i < 5, r[i]!.val < 2 ^ 52) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Mul.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Mul<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::mul",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.LOW_51_BIT_MASK",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.LOW_51_BIT_MASK_body",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul.m"],
   "lines": "L117-L215",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem neg_spec (r : backend.serial.u64.field.FieldElement51)\n    (h : ∀ i < 5, r[i]!.val < 2 ^ 54) :\n    ∃ r_inv, backend.serial.u64.field.NegShared0FieldElement51FieldElement51.neg r = ok r_inv ∧\n    (Field51_as_Nat r + Field51_as_Nat r_inv) % p = 0 ∧\n    (∀ i < 5, r_inv[i]!.val ≤ 2^51 + (2^13 - 1) * 19) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Neg.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.field.FieldElement51.neg`**:\n- No panic (always returns successfully under standard bounds)\n- Delegates to `negate`, hence returns the additive inverse modulo p\n- Input bound assumption: all limbs of the input are < 2^54 (as in `negate_spec`)\n- Output bound matches `negate_spec` -/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Neg<curve25519_dalek::backend::serial::u64::field::FieldElement51> for &0 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::neg",
   "nested_children": [],
   "lines": "L220-L224",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.NegShared0FieldElement51FieldElement51.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.negate"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::SubAssign<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51)> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::sub_assign",
   "nested_children": [],
   "lines": "L78-L81",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.SubAssignFieldElement51SharedAFieldElement51.sub_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec (a b : Array U64 5#usize)\n    (h_bounds_a : ∀ i < 5, a[i]!.val < 2 ^ 63)\n    (h_bounds_b : ∀ i < 5, b[i]!.val < 2 ^ 54) :\n    ∃ d, sub a b = ok d ∧\n    (∀ i < 5, d[i]!.val < 2 ^ 52) ∧\n    (Field51_as_Nat d + Field51_as_Nat b) % p = Field51_as_Nat a % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/Sub.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `backend.serial.u64.field.FieldElement51.sub`**:\n- No panic (always returns successfully when bounds are satisfied)\n- The result d satisfies the field subtraction property:\n\n  Field51_as_Nat(d) ≡ Field51_as_Nat(a) - Field51_as_Nat(b) (mod p), or equivalently\n  Field51_as_Nat(d) + Field51_as_Nat(b) ≡ Field51_as_Nat(a) (mod p)\n\n- Requires that input limbs are bounded:\n  - For a: limbs must allow addition with 16*p without U64 overflow\n    - a[0] must be ≤ 18410715276690587951 (= 2^64 - 1 - 36028797018963664)\n    - a[1..4] must be ≤ 18410715276690587663 (= 2^64 - 1 - 36028797018963952)\n  - For b: limbs must be ≤ the constants (representing 16*p) to avoid underflow\n    - b[0] must be ≤ 36028797018963664\n    - b[1..4] must be ≤ 36028797018963952\n  To make the theorem more easily readable and provable, we\n  replace these precise bounds with the slightly looser bounds\n  a[i] < 2^63  and b[i] < 2^54\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{core::ops::arith::Sub<&'a (curve25519_dalek::backend::serial::u64::field::FieldElement51), curve25519_dalek::backend::serial::u64::field::FieldElement51> for &1 (curve25519_dalek::backend::serial::u64::field::FieldElement51)}::sub",
   "nested_children": [],
   "lines": "L86-L103",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.reduce"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::field::FieldElement51}::zeroize",
   "nested_children": [],
   "lines": "L53-L55",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.field.ZeroizeFieldElement51.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::clone::Clone for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::clone",
   "nested_children": [],
   "lines": "L25-L25",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.CloneScalar52.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::IndexMut<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::index_mut",
   "nested_children": [],
   "lines": "L49-L51",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.IndexMutScalar52UsizeU64.index_mut",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{core::ops::index::Index<usize, u64> for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::index",
   "nested_children": [],
   "lines": "L43-L45",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.IndexScalar52UsizeU64.index",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ZERO_spec : Scalar52_as_Nat ZERO = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Zero.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.ZERO`**:\n\nThe ZERO constant represents the scalar 0.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::ZERO",
   "nested_children": [],
   "lines": "L62-L62",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::ZERO",
   "nested_children": [],
   "lines": "L62-L62",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_spec (a b : Scalar52)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 52) (hb : ∀ i < 5, b[i]!.val < 2 ^ 52)\n    (ha' : Scalar52_as_Nat a < L) (hb' : Scalar52_as_Nat b ≤ L) :\n    ∃ v, add a b = ok v ∧\n    Scalar52_as_Nat v ≡ Scalar52_as_Nat a + Scalar52_as_Nat b [MOD L] ∧\n    Scalar52_as_Nat v < L := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Add.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.add`**:\n- Requires the input values to be bounded by  2 ^ 259\n- The result represents the sum of the two input scalars modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::add",
   "nested_children": [],
   "lines": "L177-L192",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
    "curve25519_dalek.backend.serial.u64.constants.L"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem add_loop_spec (a b sum : Scalar52) (mask carry : U64) (i : Usize)\n    (ha : ∀ j < 5, a[j]!.val < 2 ^ 52) (hb : ∀ j < 5, b[j]!.val < 2 ^ 52)\n    (ha' : Scalar52_as_Nat a < 2 ^ 259) (hb' : Scalar52_as_Nat b < 2 ^ 259)\n    (hmask : mask.val = 2 ^ 52 - 1) (hi : i.val ≤ 5)\n    (hcarry : i.val = 5 → carry.val < 2 ^ 52)\n    (hcarry : ∀ i < 5, carry.val < 2 ^ 53)\n    (hsum : ∀ j < 5, sum[j]!.val < 2 ^ 52)\n    (hsum' : ∀ j < 5, i.val ≤ j → sum[j]!.val = 0) :\n    ∃ sum', add_loop a b sum mask carry i = ok sum' ∧\n    (∀ j < 5, sum'[j]!.val < 2 ^ 52) ∧\n    (∀ j < i.val, sum'[j]!.val = sum[j]!.val) ∧\n    ∑ j ∈ Finset.Ico i.val 5, 2 ^ (52 * j) * sum'[j]!.val =\n      ∑ j ∈ Finset.Ico i.val 5, 2 ^ (52 * j) * (a[j]!.val + b[j]!.val) +\n      2 ^ (52 * i.val) * (carry.val / 2 ^ 52) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Add.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.add_loop`**:\n- Starting from index `i` with accumulator `sum` and carry `carry`\n- Computes limb-wise addition with carry propagation\n- Result limbs are bounded by 2^52\n- Parts of sum before index i are preserved\n- The result satisfies the modular arithmetic property -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::add",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop._unsafe_rec",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop.mutual"],
   "lines": "L184-L188",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_montgomery_spec (u : Scalar52) (h : ∀ i < 5, u[i]!.val < 2 ^ 62) :\n    ∃ m, as_montgomery u = ok m ∧\n    Scalar52_as_Nat m ≡ (Scalar52_as_Nat u * R) [MOD L] ∧\n    (∀ i < 5, m[i]!.val < 2 ^ 62) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/AsMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.as_montgomery`**:\n- No panic (always returns successfully)\n- The result represents the input scalar multiplied by the Montgomery constant R = 2^260, modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::as_montgomery",
   "nested_children": [],
   "lines": "L338-L340",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
    "curve25519_dalek.backend.serial.u64.constants.RR"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_add_l_spec (self : Scalar52) (condition : subtle.Choice)\n    (hself : ∀ i < 5, self[i]!.val < 2 ^ 52)\n    (hself' : condition = Choice.one → 2 ^ 260 ≤ Scalar52_as_Nat self + L)\n    (hself'' : condition = Choice.one → Scalar52_as_Nat self < 2 ^ 260)\n    (hself''' : condition = Choice.zero → Scalar52_as_Nat self < L) :\n    ∃ result, conditional_add_l self condition = ok result ∧\n    (∀ i < 5, result.2[i]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat result.2 < L) ∧\n    (condition = Choice.one → Scalar52_as_Nat result.2 + 2 ^ 260 = Scalar52_as_Nat self + L) ∧\n    (condition = Choice.zero → Scalar52_as_Nat result.2 = Scalar52_as_Nat self) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/ConditionalAddL.lean",
   "spec_docstring":
   "/-- **Spec for `scalar.Scalar52.conditional_add_l`** (tailored for use in `sub`):\n- Requires input limbs bounded by 2^52\n- When condition is 1, requires input value in [2^260 - L, 2^260)\n- When condition is 1: result + 2^260 = input + L, with result < L and limbs < 2^52\n- When condition is 0: result unchanged with limbs < 2^52\n- Carry value not specified (not used by sub)\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l",
   "nested_children": [],
   "lines": "L213-L226",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem conditional_add_l_loop_spec (self : Scalar52) (condition : subtle.Choice)\n    (carry : U64) (mask : U64) (i : Usize)\n    (hself : ∀ j < 5, self[j]!.val < 2 ^ 52)\n    (hmask : mask.val = 2 ^ 52 - 1) (hi : i.val ≤ 5)\n    (hcarry : carry.val < 2 ^ 53) :\n    ∃ result, conditional_add_l_loop self condition carry mask i = ok result ∧\n    (∀ j < 5, result.2[j]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat result.2 + 2 ^ 260 * (result.1.val / 2 ^ 52) =\n      Scalar52_as_Nat self + (if condition.val = 1#u8 then Scalar52_as_Nat constants.L else 0) +\n      2 ^ (52 * i.val) * (carry.val / 2 ^ 52) -\n      (if condition.val = 1#u8 then ∑ j ∈ Finset.Ico 0 i.val, 2 ^ (52 * j) * constants.L[j]!.val else 0)) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/ConditionalAddL.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::conditional_add_l",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop.mutual",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop._unsafe_rec"],
   "lines": "L218-L218",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_spec (b : Array U8 32#usize) :\n    ∃ u,\n    from_bytes b = ok u ∧\n    Scalar52_as_Nat u = U8x32_as_Nat b ∧\n    ∀ i < 5, u[i]!.val < 2 ^ 52\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.from_bytes`**:\n- No panic (always returns successfully)\n- The result represents the same number as the input byte array\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes.match_1"],
   "lines": "L66-L93",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_loop",
    "curve25519_dalek.backend.serial.u64.scalar.IndexMutScalar52UsizeU64.index_mut",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_loop._unsafe_rec"],
   "lines": "L69-L80",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_wide_spec (b : Array U8 64#usize) :\n    ∃ u, from_bytes_wide b = ok u ∧\n    Scalar52_as_Nat u = U8x64_as_Nat b % L := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromBytesWide.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.from_bytes_wide`**:\n- No panic (always returns successfully)\n- The result represents the input byte array reduced modulo L (canonical form) -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes_wide",
   "nested_children": [],
   "lines": "L97-L132",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide_loop",
    "curve25519_dalek.backend.serial.u64.scalar.IndexMutScalar52UsizeU64.index_mut",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
    "curve25519_dalek.backend.serial.u64.constants.R",
    "curve25519_dalek.backend.serial.u64.constants.RR",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_bytes_wide",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide_loop._unsafe_rec"],
   "lines": "L100-L111",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_montgomery_spec (self : Scalar52)\n    (h_bounds : ∀ i < 5, self[i]!.val < 2 ^ 62) :\n    ∃ u, from_montgomery self = ok u ∧\n    (Scalar52_as_Nat u * R) % L = Scalar52_as_Nat self % L := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.from_montgomery`**:\n- No panic (always returns successfully)\n- The result represents the input scalar divided by the Montgomery constant R = 2^260, modulo L\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_montgomery",
   "nested_children": [],
   "lines": "L345-L353",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_montgomery_loop_spec (self : Scalar52) (limbs : Array U128 9#usize) (i : Usize)\n    (hi : i.val ≤ 5) :\n    ∃ result, from_montgomery_loop self limbs i = ok result ∧\n    (∀ j < 5, i.val ≤ j → result[j]! = UScalar.cast .U128 self[j]!) ∧\n    (∀ j < 9, 5 ≤ j → result[j]! = limbs[j]!) ∧\n    (∀ j < i.val, result[j]! = limbs[j]!) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/FromMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `from_montgomery_loop`**:\n- Specification for the loop that copies limbs from a Scalar52 (5 × U64) into a 9-element U128 array\n- Ensures that:\n  - The loop always succeeds (no panic)\n  - Limbs at indices [i, 5) are copied from the input Scalar52 to the result array\n  - Limbs at indices [5, 9) remain unchanged from the input limbs array\n  - Limbs at indices [0, i) remain unchanged from the input limbs array\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::from_montgomery",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery_loop._unsafe_rec"],
   "lines": "L348-L351",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.IndexScalar52UsizeU64.index"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem montgomery_mul_spec (m m' : Scalar52)\n    (hm : ∀ i < 5, m[i]!.val < 2 ^ 62) (hm' : ∀ i < 5, m'[i]!.val < 2 ^ 62) :\n    ∃ w, montgomery_mul m m' = ok w ∧\n    (Scalar52_as_Nat m * Scalar52_as_Nat m') ≡ (Scalar52_as_Nat w * R) [MOD L] ∧\n    (∀ i < 5, w[i]!.val < 2 ^ 62) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomeryMul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_mul`**:\n- No panic (always returns successfully)\n- The result w satisfies the Montgomery multiplication property:\n  (m * m') ≡ w * R (mod L), where R = 2^260 is the Montgomery constant\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_mul",
   "nested_children": [],
   "lines": "L326-L328",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem montgomery_reduce_spec (a : Array U128 9#usize)\n    (h_bounds : ∀ i < 9, a[i]!.val < 2 ^ 127) :\n    ∃ m,\n    montgomery_reduce a = ok m ∧\n    (Scalar52_as_Nat m * R) % L = Scalar52_wide_as_Nat a % L ∧\n    (∀ i < 5, m[i]!.val < 2 ^ 62)\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomeryReduce.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_reduce`**:\n- No panic (always returns successfully)\n- The result m satisfies the Montgomery reduction property:\n  m * R ≡ a (mod L), where R = 2^260 is the Montgomery constant\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_reduce",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.match_1",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.part2",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce.part1"],
   "lines": "L274-L307",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.IndexScalar52UsizeU64.index",
    "curve25519_dalek.backend.serial.u64.constants.L",
    "curve25519_dalek.backend.serial.u64.scalar.m",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem montgomery_square_spec (m : Scalar52) (hm : ∀ i < 5, m[i]!.val < 2 ^ 62) :\n    ∃ w,\n    montgomery_square m = ok w ∧\n    (Scalar52_as_Nat m * Scalar52_as_Nat m) % L = (Scalar52_as_Nat w * R) % L ∧\n    (∀ i < 5, w[i]!.val < 2 ^ 62)\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomerySquare.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_square`**:\n- No panic (always returns successfully)\n- The result w satisfies the Montgomery squaring property:\n  (m * m) ≡ w * R (mod L), where R = 2^260 is the Montgomery constant\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_square",
   "nested_children": [],
   "lines": "L332-L334",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_square",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.square_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::mul",
   "nested_children": [],
   "lines": "L311-L314",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.backend.serial.u64.constants.RR"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_internal_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 62) (hb : ∀ i < 5, b[i]!.val < 2 ^ 62) :\n    ∃ result, mul_internal a b = ok (result) ∧\n    Scalar52_wide_as_Nat result = Scalar52_as_Nat a * Scalar52_as_Nat b ∧\n    (∀ i < 9, result[i]!.val < 2 ^ 127) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MulInternal.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.mul_internal`**:\n- Does not error and hence returns a result\n- The result represents the product of the two input field elements\n- Requires that each input limb is at most 62 bits to prevent overflow -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::mul_internal",
   "nested_children": [],
   "lines": "L231-L245",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.IndexScalar52UsizeU64.index",
    "curve25519_dalek.backend.serial.u64.scalar.m"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::square",
   "nested_children": [],
   "lines": "L319-L322",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.square",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.square_internal",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.constants.RR"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem square_internal_spec (a : Array U64 5#usize) (ha : ∀ i, i < 5 → (a[i]!).val < 2 ^ 62) :\n    ∃ result, square_internal a = ok (result) ∧\n    Scalar52_wide_as_Nat result = Scalar52_as_Nat a * Scalar52_as_Nat a ∧\n    (∀ i < 9, result[i]!.val < 2 ^ 127) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/SquareInternal.lean",
   "spec_docstring":
   "/-- **Spec for `square_internal`**:\n- Does not error and hence returns a result\n- The result represents the square of the input field element\n- Requires each limb to be less than 62 bits to prevent overflow\n(The optimal bound on the limbs is 2^64 / √5  ≈ 2^62.839) -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::square_internal",
   "nested_children": [],
   "lines": "L250-L269",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.Scalar52.square_internal",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.IndexScalar52UsizeU64.index",
    "curve25519_dalek.backend.serial.u64.scalar.m"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_spec (a b : Array U64 5#usize)\n    (ha : ∀ i < 5, a[i]!.val < 2 ^ 52)\n    (hb : ∀ i < 5, b[i]!.val < 2 ^ 52)\n    (ha' : Scalar52_as_Nat a < Scalar52_as_Nat b + L)\n    (hb' : Scalar52_as_Nat b ≤ L) :\n    ∃ result, sub a b = ok result ∧\n    Scalar52_as_Nat result + Scalar52_as_Nat b ≡ Scalar52_as_Nat a [MOD L] ∧\n    Scalar52_as_Nat result < L ∧\n    (∀ i < 5, result[i]!.val < 2 ^ 52) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Sub.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.sub`**:\n- Requires bounded limbs for both inputs\n- Requires both inputs to be bounded from above\n- The result represents (a - b) mod L\n- The result has bounded limbs and is canonical -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub.match_1",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub.match_3"],
   "lines": "L195-L211",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.conditional_add_l"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sub_loop_spec (a b difference : Scalar52) (mask borrow : U64) (i : Usize)\n    (ha : ∀ j < 5, a[j]!.val < 2 ^ 52)\n    (hb : ∀ j < 5, b[j]!.val < 2 ^ 52)\n    (hdiff : ∀ j < i.val, difference[j]!.val < 2 ^ 52)\n    (hdiff_rest : ∀ j, i.val ≤ j → j < 5 → difference[j]!.val = 0)\n    (hmask : mask.val = 2 ^ 52 - 1)\n    (hi : i.val ≤ 5)\n    (hborrow : borrow.val / 2 ^ 63 ≤ 1)\n    (hinv : Scalar52_partial_as_Nat a i.val + borrow.val / 2 ^ 63 * 2 ^ (52 * i.val) =\n            Scalar52_partial_as_Nat b i.val + Scalar52_partial_as_Nat difference i.val) :\n    ∃ result, sub_loop a b difference mask borrow i = ok result ∧\n    (∀ j < 5, result.1[j]!.val < 2 ^ 52) ∧\n    (Scalar52_as_Nat a + result.2.val / 2 ^ 63 * 2 ^ 260 =\n     Scalar52_as_Nat b + Scalar52_as_Nat result.1) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Sub.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.Scalar52.sub_loop`**:\n\nThe loop computes the subtraction a - b with borrow propagation.\nAfter processing indices 0..i, the loop invariant holds:\n  partial_a(i) + (borrow / 2^63) * 2^(52*i) = partial_b(i) + partial_diff(i)\n\nWhen the loop completes (i = 5), this gives:\n  A + (borrow / 2^63) * 2^260 = B + D\n\nWhere (borrow / 2^63) = 1 means A < B (underflow occurred), and the difference D\nrepresents (A - B) mod 2^260.\n-/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::sub",
   "nested_children":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop.mutual",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop._unsafe_rec"],
   "lines": "L202-L206",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (u : Scalar52) :\n    ∃ b, to_bytes u = ok b ∧\n    U8x32_as_Nat b ≡ Scalar52_as_Nat u [MOD L] ∧\n    U8x32_as_Nat b < L := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.to_bytes`**:\n- No panic (always returns successfully)\n- The result byte array represents the same number as the input unpacked scalar modulo L\n- The result is in canonical form (less than L) -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::to_bytes",
   "nested_children": [],
   "lines": "L137-L174",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.Scalar52.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::scalar::Scalar52}::zeroize",
   "nested_children": [],
   "lines": "L36-L38",
   "lean_name":
   "curve25519_dalek.backend.serial.u64.scalar.ZeroizeScalar52.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem m_spec (x y : U64) :\n    ∃ result, m x y = ok (result) ∧\n    result.val = x.val * y.val := by ...",
   "spec_file": "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/M.lean",
   "spec_docstring":
   "/-- **Spec for `backend.serial.u64.scalar.m`**:\n- Does not overflow and hence returns a result\n- The result equals the product of the two input values -/",
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name": "curve25519_dalek::backend::serial::u64::scalar::m",
   "nested_children": [],
   "lines": "L56-L58",
   "lean_name": "curve25519_dalek.backend.serial.u64.scalar.m",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/mod.rs",
   "rust_name": "curve25519_dalek::backend::variable_base_mul",
   "nested_children": [],
   "lines": "L253-L263",
   "lean_name": "curve25519_dalek.backend.variable_base_mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.get_selected_backend",
    "curve25519_dalek.backend.serial.scalar_mul.variable_base.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/constants.rs",
   "rust_name": "curve25519_dalek::constants::BASEPOINT_ORDER_PRIVATE",
   "nested_children": [],
   "lines": "L75-L81",
   "lean_name": "curve25519_dalek.constants.BASEPOINT_ORDER_PRIVATE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.constants.BASEPOINT_ORDER_PRIVATE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/constants.rs",
   "rust_name": "curve25519_dalek::constants::BASEPOINT_ORDER_PRIVATE",
   "nested_children": [],
   "lines": "L75-L81",
   "lean_name": "curve25519_dalek.constants.BASEPOINT_ORDER_PRIVATE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/constants.rs",
   "rust_name": "curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT",
   "nested_children": [],
   "lines": "L66-L66",
   "lean_name": "curve25519_dalek.constants.RISTRETTO_BASEPOINT_POINT",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.constants.RISTRETTO_BASEPOINT_POINT_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/constants.rs",
   "rust_name": "curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT",
   "nested_children": [],
   "lines": "L66-L66",
   "lean_name": "curve25519_dalek.constants.RISTRETTO_BASEPOINT_POINT_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem add_spec (self other : EdwardsPoint)\n\n    (h_self_bounds : ∀ i < 5,\n      self.X[i]!.val < 2 ^ 53 ∧\n      self.Y[i]!.val < 2 ^ 53 ∧\n      self.Z[i]!.val < 2 ^ 53 ∧\n      self.T[i]!.val < 2 ^ 53)\n\n    (h_other_bounds : ∀ i < 5,\n      other.X[i]!.val < 2 ^ 53 ∧\n      other.Y[i]!.val < 2 ^ 53 ∧\n      other.Z[i]!.val < 2 ^ 53 ∧\n      other.T[i]!.val < 2 ^ 53)\n\n    (h_self_Z_nonzero : Field51_as_Nat self.Z % p ≠ 0)\n    (h_other_Z_nonzero : Field51_as_Nat other.Z % p ≠ 0) :\n\n    ∃ result, add self other = ok result ∧\n\n    (∀ i < 5,\n      result.X[i]!.val < 2 ^ 54  ∧\n      result.Y[i]!.val < 2 ^ 54  ∧\n      result.Z[i]!.val < 2 ^ 54  ∧\n      result.T[i]!.val < 2 ^ 54) ∧\n\n    let X₁ := Field51_as_Nat self.X\n    let Y₁ := Field51_as_Nat self.Y\n    let Z₁ := Field51_as_Nat self.Z\n    let T₁ := Field51_as_Nat self.T\n\n    let X₂ := Field51_as_Nat other.X\n    let Y₂ := Field51_as_Nat other.Y\n    let Z₂ := Field51_as_Nat other.Z\n    let T₂ := Field51_as_Nat other.T\n\n    let X₃ := Field51_as_Nat result.X\n    let Y₃ := Field51_as_Nat result.Y\n    let Z₃ := Field51_as_Nat result.Z\n    let T₃ := Field51_as_Nat result.T\n\n    X₃ % p = ((X₁ * Y₂ + Y₁ * X₂) * (Z₁ * Z₂ - d * T₁ * T₂)) % p ∧\n    Y₃ % p = ((Y₁ * Y₂ - a * X₁ * X₂) * (Z₁ * Z₂ + d * T₁ * T₂)) % p ∧\n    T₃ % p = ((Y₁ * Y₂ - a * X₁ * X₂) * (X₁ * Y₂ + Y₁ * X₂)) % p ∧\n    Z₃ % p = ((Z₁ * Z₂ - d * T₁ * T₂) * (Z₁ * Z₂ + d * T₁ * T₂)) % p := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Add.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.add`**:\n- No panic (always returns successfully)\n- Returns the sum P + Q (in elliptic curve addition) where P = self and Q = other\n- The resulting point's coordinates satisfy the twisted Edwards addition formulas modulo\n (see Section 3.1 in https://www.iacr.org/archive/asiacrypt2008/53500329/53500329.pdf)\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::edwards::EdwardsPoint}::add",
   "nested_children": [],
   "lines": "L33-L35",
   "lean_name":
   "curve25519_dalek.edwards.AddEdwardsPointEdwardsPointEdwardsPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.AddShared0EdwardsPointSharedAEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Add<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::add",
   "nested_children": [],
   "lines": "L755-L757",
   "lean_name":
   "curve25519_dalek.edwards.AddShared0EdwardsPointSharedAEdwardsPointEdwardsPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
    "curve25519_dalek.backend.serial.curve_models.AddShared0EdwardsPointSharedAProjectiveNielsPointCompletedPoint.add",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec\n    (self : edwards.CompressedEdwardsY) :\n    ∃ result, as_bytes self = ok result ∧\n    result = self := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/CompressedEdwardsY/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec for `edwards.CompressedEdwardsY.as_bytes`**:\n- The function succeeds (always returns `ok`)\n- The result is exactly the internal byte array representation.\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::as_bytes",
   "nested_children": [],
   "lines": "L189-L191",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem decompress_spec (cey : edwards.CompressedEdwardsY) :\n    ∃ result, edwards.CompressedEdwardsY.decompress cey = ok result ∧\n\n      (∀ ep, result = some ep →\n        let y_encoded := (U8x32_as_Nat cey) % (2^255)\n        let x_sign_bit := cey[31]!.val.testBit 7\n\n        (∃ Z_inv x_val y_val x_is_neg,\n          field.FieldElement51.invert ep.Z = ok Z_inv ∧\n          (Field51_as_Nat ep.X * Field51_as_Nat Z_inv) % p = x_val ∧\n          (Field51_as_Nat ep.Y * Field51_as_Nat Z_inv) % p = y_val ∧\n          field.FieldElement51.is_negative ep.X = ok x_is_neg ∧\n\n          (y_val * y_val % p = (x_val * x_val + 1 + d * x_val * x_val * y_val * y_val) % p) ∧\n\n          y_val % p = y_encoded % p ∧\n\n          (x_sign_bit ↔ x_is_neg.val = 1#u8) ∧\n\n          (Field51_as_Nat ep.T % p = (Field51_as_Nat ep.X * Field51_as_Nat ep.Y) % p))) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/CompressedEdwardsY/Decompress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.CompressedEdwardsY.decompress`**:\n- No panic (always returns successfully)\n- If the function returns Some(ep) with ep = (X, Y, Z, T), then:\n  - The affine coordinates (x,y) where x = X/Z and y = Y/Z satisfy the curve equation\n    ax² + y² = 1 + dx²y² (mod p)\n  - y equals the y-coordinate encoded in the input byte array (bytes 0-30 and low 7 bits of byte 31)\n  - The sign (parity) of x matches the high bit of byte 31 in the input byte array\n  - T = X * Y (mod p)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::decompress",
   "nested_children":
   ["curve25519_dalek.edwards.CompressedEdwardsY.decompress.match_1"],
   "lines": "L202-L210",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.decompress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.decompress.step_1",
    "curve25519_dalek.edwards.decompress.step_2"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::CompressedEdwardsY}::to_bytes",
   "nested_children": [],
   "lines": "L194-L196",
   "lean_name": "curve25519_dalek.edwards.CompressedEdwardsY.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem ct_eq_spec (e1 e2 : EdwardsPoint)\n  -- Bounds are needed for the internal field multiplications\n  (h_e1_X : ∀ i, i < 5 → e1.X.val[i]!.val ≤ 2 ^ 53)\n  (h_e1_Y : ∀ i, i < 5 → e1.Y.val[i]!.val ≤ 2 ^ 53)\n  (h_e1_Z : ∀ i, i < 5 → e1.Z.val[i]!.val ≤ 2 ^ 53)\n  (h_e2_X : ∀ i, i < 5 → e2.X.val[i]!.val ≤ 2 ^ 53)\n  (h_e2_Y : ∀ i, i < 5 → e2.Y.val[i]!.val ≤ 2 ^ 53)\n  (h_e2_Z : ∀ i, i < 5 → e2.Z.val[i]!.val ≤ 2 ^ 53) :\n  ∃ c,\n  ct_eq e1 e2 = ok c ∧\n  (c = Choice.one ↔\n    (Field51_as_Nat e1.X * Field51_as_Nat e2.Z) ≡ (Field51_as_Nat e2.X * Field51_as_Nat e1.Z) [MOD p] ∧\n    (Field51_as_Nat e1.Y * Field51_as_Nat e2.Z) ≡ (Field51_as_Nat e2.Y * Field51_as_Nat e1.Z) [MOD p]) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/CtEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.ConstantTimeEqEdwardsPoint.ct_eq`**:\n- No panic (always returns successfully)\n- The result is Choice.one (true) if and only if the two points are equal (mod p) in affine coordinates\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{subtle::ConstantTimeEq for curve25519_dalek::edwards::EdwardsPoint}::ct_eq",
   "nested_children": [],
   "lines": "L493-L502",
   "lean_name": "curve25519_dalek.edwards.ConstantTimeEqEdwardsPoint.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.field.ConstantTimeEqFieldElement51.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::as_affine_niels",
   "nested_children": [],
   "lines": "L542-L552",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.as_affine_niels",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_projective_spec (e : EdwardsPoint) :\n    ∃ q, edwards.EdwardsPoint.as_projective e = ok q ∧\n    q.X = e.X ∧ q.Y = e.Y ∧ q.Z = e.Z := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/AsProjective.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.as_projective`**:\n- No panic (always returns successfully)\n- The resulting ProjectivePoint coordinates match the EdwardsPoint coordinates (X, Y, Z)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::as_projective",
   "nested_children": [],
   "lines": "L532-L538",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.as_projective",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_projective_niels_spec (e : EdwardsPoint)\n    (h_bounds : ∀ i < 5, e.X[i]!.val < 2 ^ 53 ∧ e.Y[i]!.val < 2 ^ 53 ∧\n      e.Z[i]!.val < 2 ^ 53 ∧ e.T[i]!.val < 2 ^ 53) :\n    ∃ pn, as_projective_niels e = ok pn ∧\n    let X := Field51_as_Nat e.X\n    let Y := Field51_as_Nat e.Y\n    let Z := Field51_as_Nat e.Z\n    let T := Field51_as_Nat e.T\n    let A := Field51_as_Nat pn.Y_plus_X\n    let B := Field51_as_Nat pn.Y_minus_X\n    let Z' := Field51_as_Nat pn.Z\n    let C := Field51_as_Nat pn.T2d\n    let d2 := Field51_as_Nat EDWARDS_D2\n    A % p = (Y + X) % p ∧\n    (B + X) % p = Y % p ∧\n    Z' % p = Z % p ∧\n    C % p = (T * d2) % p := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/EdwardsPoint/AsProjectiveNiels.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.as_projective_niels`**:\n- No panic (always returns successfully)\n- For the input Edwards point (X, Y, Z, T), the resulting ProjectiveNielsPoint has coordinates:\n  - A ≡ Y + X (mod p)\n  - B ≡ Y - X (mod p)\n  - Z' = Z\n  - C ≡ T * 2 * d (mod p)\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::as_projective_niels",
   "nested_children": [],
   "lines": "L519-L526",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D2"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem compress_spec (self : EdwardsPoint) (hX : ∀ i < 5, self.X[i]!.val < 2 ^ 54)\n      (hY : ∀ i < 5, self.Y[i]!.val < 2 ^ 54) (hZ : ∀ i < 5, self.Z[i]!.val < 2 ^ 54)\n      -- (hself : self.IsValid)\n      :\n    ∃ result, compress self = ok result -- ∧\n    -- result.IsValid ∧ result.toPoint = self.toPoint\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Compress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.compress`**:\n- No panic when Z is invertible / not zero (always returns successfully)\n- On success, returns a CompressedEdwardsY (U8x32 byte array) where:\n  - Bytes 0-30 and the low 7 bits of byte 31 encode the affine y-coordinate in little-endian\n  - The high bit of byte 31 encodes the sign (parity) of the affine x-coordinate\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::compress",
   "nested_children": [],
   "lines": "L606-L608",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.compress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.to_affine",
    "curve25519_dalek.edwards.affine.AffinePoint.compress"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem double_spec (e : EdwardsPoint) (he_valid : e.IsValid):\n    ∃ result, double e = ok result\n    ∧ result.IsValid ∧ result.toPoint = e.toPoint + e.toPoint := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Double.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.double`**:\n- No panic (always returns successfully)\n- Returns the doubled point 2P (= P + P in elliptic curve addition) where P is the input EdwardsPoint\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::double",
   "nested_children": [],
   "lines": "L744-L746",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.double",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_small_order_spec (self : EdwardsPoint) (hself : self.IsValid) :\n    ∃ result : Bool, is_small_order self = ok result ∧\n    (result ↔ h • self.toPoint = 0) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/IsSmallOrder.lean",
   "spec_docstring":
   "/-- **Spec for `edwards.EdwardsPoint.is_small_order`**:\n- Returns `true` if and only if the point has small order (is in the torsion subgroup E[8])\n- This is determined by checking if multiplying by the cofactor yields the identity element\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::is_small_order",
   "nested_children": [],
   "lines": "L1366-L1368",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.is_small_order",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.mul_by_cofactor",
    "curve25519_dalek.traits.IdentityEdwardsPoint"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::is_torsion_free",
   "nested_children": [],
   "lines": "L1396-L1398",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.is_torsion_free",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulSharedAEdwardsPointScalarEdwardsPoint.mul",
    "curve25519_dalek.constants.BASEPOINT_ORDER_PRIVATE",
    "curve25519_dalek.traits.IdentityEdwardsPoint"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_base_spec (scalar : scalar.Scalar) :\n    ∃ res,\n    mul_base scalar = ok res ∧\n    EdwardsPoint.IsValid res ∧\n    res.toPoint = (U8x32_as_Nat scalar.bytes) • constants.ED25519_BASEPOINT_POINT.toPoint := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulBase.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_base`**:\n- No panic (always returns successfully)\n- Delegates to scalar multiplication with the Edwards basepoint constant\n- The returned EdwardsPoint equals the output of that scalar multiplication\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_base",
   "nested_children": [],
   "lines": "L876-L886",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_base",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulSharedAScalarEdwardsPointEdwardsPoint.mul",
    "curve25519_dalek.backend.serial.u64.constants.ED25519_BASEPOINT_POINT"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_base_clamped",
   "nested_children": [],
   "lines": "L906-L914",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_base_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.edwards.EdwardsPoint.mul_base"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_by_cofactor_spec (self : EdwardsPoint) (hself : self.IsValid) :\n    ∃ result, mul_by_cofactor self = ok result ∧\n    result.IsValid ∧\n    result.toPoint = h • self.toPoint := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulByCofactor.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_by_cofactor`**:\n- No panic (always returns successfully)\n- Returns an EdwardsPoint that represents 8e = (2 ^ 3) * e\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_by_cofactor",
   "nested_children": [],
   "lines": "L1324-L1326",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_by_cofactor",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_by_pow_2_spec (self : EdwardsPoint) (k : U32) (hself : self.IsValid) (hk : k.val > 0) :\n    ∃ result : EdwardsPoint, mul_by_pow_2 self k = ok result ∧\n    result.IsValid ∧\n    result.toPoint = (2 ^ k.val) • self.toPoint := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/MulByPow2.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.mul_by_pow_2`**:\n- For k = 1, returns the doubled point 2e for the input point e\n- For k > 1, returns a point equal to double(mul_by_pow_2(e, k-1))\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_by_pow_2",
   "nested_children": [],
   "lines": "L1329-L1341",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective",
    "curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2_loop",
    "curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_by_pow_2",
   "nested_children":
   ["curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2_loop._unsafe_rec"],
   "lines": "L1334-L1338",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_by_pow_2_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ProjectivePoint.double",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_projective"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::mul_clamped",
   "nested_children": [],
   "lines": "L890-L902",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.mul_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.edwards.MulScalarEdwardsPointEdwardsPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_affine_spec (e : EdwardsPoint)\n    (hX : ∀ i < 5, e.X[i]!.val < 2 ^ 54)\n    (hY : ∀ i < 5, e.Y[i]!.val < 2 ^ 54)\n    (hZ : ∀ i < 5, e.Z[i]!.val < 2 ^ 54) :\n    ∃ ap,\n    to_affine e = ok ap ∧\n\n    let X := Field51_as_Nat e.X\n    let Y := Field51_as_Nat e.Y\n    let Z := Field51_as_Nat e.Z\n    let x := Field51_as_Nat ap.x\n    let y := Field51_as_Nat ap.y\n\n    (if Z % p = 0 then\n      x % p = 0 ∧ y % p = 0\n    else\n      (x * Z) % p = X % p ∧\n      (y * Z) % p = Y % p) ∧\n      (∀ i < 5, ap.x[i]!.val < 2 ^ 52) ∧\n      (∀ i < 5, ap.y[i]!.val < 2 ^ 52) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/ToAffine.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.to_affine`**:\n- No panic (always returns successfully)\n- For the input Edwards point (X, Y, Z, T), the resulting AffinePoint has coordinates:\n  - If Z ≢ 0 (mod p): x * Z ≡ X (mod p) and y * Z ≡ Y (mod p)\n  - If Z ≡ 0 (mod p): x ≡ 0 (mod p) and y ≡ 0 (mod p)\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::to_affine",
   "nested_children": [],
   "lines": "L555-L560",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.to_affine",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_montgomery_spec (e : EdwardsPoint)\n    (h_Y_bounds : ∀ i < 5, e.Y[i]!.val < 2 ^ 53) (h_Z_bounds : ∀ i < 5, e.Z[i]!.val < 2 ^ 53) :\n    ∃ mp, to_montgomery e = ok mp ∧\n    let Y := Field51_as_Nat e.Y\n    let Z := Field51_as_Nat e.Z\n    let u := U8x32_as_Nat mp\n    if Z % p = Y % p then\n      u % p = 0\n    else\n      (u * Z) % p = (u * Y + (Z + Y)) % p := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/ToMontgomery.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.EdwardsPoint.to_montgomery`**:\n- No panic (always returns successfully)\n- For the input Edwards point (X, Y, Z, T), the resulting MontgomeryPoint has u-coordinate:\n  - If Z ≢ Y (mod p): u ≡ (Z+Y) * (Z-Y)^(-1) (mod p)\n  - If Z ≡ Y (mod p): u ≡ 0 (mod p)\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::edwards::EdwardsPoint}::to_montgomery",
   "nested_children": [],
   "lines": "L571-L581",
   "lean_name": "curve25519_dalek.edwards.EdwardsPoint.to_montgomery",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    ∃ q, identity = ok q ∧\n    q.X = ZERO ∧ q.Y = ONE ∧ q.Z = ONE ∧ q.T = ZERO := by ...",
   "spec_file": "Curve25519Dalek/Specs/Edwards/EdwardsPoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.IdentityEdwardsPoint.identity`**:\n- No panic (always returns successfully)\n- The resulting EdwardsPoint is the identity element with coordinates (X=0, Y=1, Z=1, T=0)\n-/",
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::EdwardsPoint}::identity",
   "nested_children": [],
   "lines": "L420-L427",
   "lean_name": "curve25519_dalek.edwards.IdentityEdwardsPoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "nested_children": [],
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.edwards.MulScalarEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulShared0ScalarSharedAEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::edwards::EdwardsPoint)}::mul",
   "nested_children": [],
   "lines": "L854-L856",
   "lean_name":
   "curve25519_dalek.edwards.MulShared0EdwardsPointSharedAScalarEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.backend.variable_base_mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<&'a (curve25519_dalek::edwards::EdwardsPoint), curve25519_dalek::edwards::EdwardsPoint> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L866-L868",
   "lean_name":
   "curve25519_dalek.edwards.MulShared0ScalarSharedAEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulShared0EdwardsPointSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::edwards::EdwardsPoint)}::mul",
   "nested_children": [],
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.edwards.MulSharedAEdwardsPointScalarEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulShared0EdwardsPointSharedAScalarEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::edwards::{core::ops::arith::Mul<curve25519_dalek::edwards::EdwardsPoint, curve25519_dalek::edwards::EdwardsPoint> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.edwards.MulSharedAScalarEdwardsPointEdwardsPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulShared0ScalarSharedAEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem compress_spec (self : AffinePoint) -- (hself : self.IsValid)\n    (h : Field51_as_Nat self.y < 2 ^ 255) :\n    ∃ result, compress self = ok result -- ∧\n    -- result.IsValid ∧ result.toPoint = self.toPoint\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Edwards/Affine/AffinePoint/Compress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `edwards.affine.AffinePoint.compress`**:\n- Requires: `y`-coordinate of the AffinePoint, when converted to 32 bytes, has leading bit zero\n- Returns a CompressedEdwardsY equal to the input AffinePoint\n-/",
   "source": "curve25519-dalek/src/edwards/affine.rs",
   "rust_name":
   "curve25519_dalek::edwards::affine::{curve25519_dalek::edwards::affine::AffinePoint}::compress",
   "nested_children": [],
   "lines": "L71-L75",
   "lean_name": "curve25519_dalek.edwards.affine.AffinePoint.compress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
    "curve25519_dalek.field.FieldElement51.is_negative"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name": "curve25519_dalek::edwards::decompress::step_1",
   "nested_children": ["curve25519_dalek.edwards.decompress.step_1.match_1"],
   "lines": "L217-L228",
   "lean_name": "curve25519_dalek.edwards.decompress.step_1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.as_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.field.FieldElement51.sqrt_ratio_i"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name": "curve25519_dalek::edwards::decompress::step_2",
   "nested_children": [],
   "lines": "L231-L248",
   "lean_name": "curve25519_dalek.edwards.decompress.step_2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.CompressedEdwardsY.as_bytes",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ct_eq_spec (a b : backend.serial.u64.field.FieldElement51) :\n    ∃ c, ct_eq a b = ok c ∧\n    (c = Choice.one ↔ a.to_bytes = b.to_bytes ) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Field/FieldElement51/CtEq.lean",
   "spec_docstring":
   "/-- **Spec for `field.ConstantTimeEqFieldElement51.ct_eq`**:\n- No panic (always returns successfully)\n- Returns `Choice.one` iff the canonical encodings (32-byte LE) are equal\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{subtle::ConstantTimeEq for curve25519_dalek::backend::serial::u64::field::FieldElement51}::ct_eq",
   "nested_children": [],
   "lines": "L96-L98",
   "lean_name": "curve25519_dalek.field.ConstantTimeEqFieldElement51.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invert_spec (r : backend.serial.u64.field.FieldElement51) (h_bounds : ∀ i, i < 5 → (r[i]!).val < 2 ^ 54) :\n    ∃ r', invert r = ok r' ∧\n    let r_nat := Field51_as_Nat r % p\n    let r'_nat := Field51_as_Nat r' % p\n    (r_nat ≠ 0 → (r'_nat * r_nat) % p = 1) ∧\n    (r_nat = 0 → r'_nat = 0) ∧\n    (∀ i, i < 5 → (r'[i]!).val < 2 ^ 52)\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/Invert.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::invert",
   "nested_children": [],
   "lines": "L255-L264",
   "lean_name": "curve25519_dalek.field.FieldElement51.invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.pow22501",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invsqrt_spec\n    (v : backend.serial.u64.field.FieldElement51)\n    (h_v_bounds : ∀ i, i < 5 → (v[i]!).val ≤ 2 ^ 52 - 1)\n    (pow : Field51_as_Nat v * Field51_as_Nat v ≡ Field51_as_Nat ONE [MOD p]) :\n    ∃ res, invsqrt v = ok res ∧\n    let v_nat := Field51_as_Nat v % p\n    let r_nat := Field51_as_Nat res.snd % p\n    let i_nat := Field51_as_Nat SQRT_M1 % p\n    -- Case 1: If v ≡ 0 (mod p), then c.val = 0 and r ≡ 0 (mod p)\n    (v_nat = 0 → res.fst.val = 0#u8 ∧ r_nat = 0) ∧\n    -- Case 2: If v ≢ 0 (mod p) and ∃ x, x^2 ≡ v (mod p), then c.val = 1 and r^2 * v ≡ 1 (mod p)\n    (v_nat ≠ 0 ∧ (∃ x : Nat, x^2 % p = v_nat) → res.fst.val = 1#u8 ∧ (r_nat^2 * v_nat) % p = 1) ∧\n    -- Case 3: If v ≢ 0 (mod p) and ¬∃ x, x^2 ≡ v (mod p), then c.val = 0 and r^2 * v ≡ SQRT_M1 (mod p)\n    (v_nat ≠ 0 ∧ ¬(∃ x : Nat, x^2 % p = v_nat) →\n      res.fst.val = 0#u8 ∧ (r_nat^2 * v_nat) % p = i_nat) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/InvSqrt.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `field.FieldElement51.invsqrt`**:\n- No panic for field element inputs v (always returns (c, r) successfully)\n- The result satisfies exactly one of three mutually exclusive cases:\n  1. If v ≡ 0 (mod p), then c.val = 0 and r ≡ 0 (mod p)\n  2. If v ≢ 0 (mod p) and ∃ x, x^2 ≡ v (mod p), then c.val = 1 and r^2 * v ≡ 1 (mod p)\n  3. If v ≢ 0 (mod p) and ¬∃ x, x^2 ≡ v (mod p), then c.val = 0 and r^2 * v ≡ SQRT_M1 (mod p)\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::invsqrt",
   "nested_children": [],
   "lines": "L352-L354",
   "lean_name": "curve25519_dalek.field.FieldElement51.invsqrt",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_negative_spec (r : backend.serial.u64.field.FieldElement51) :\n    ∃ c, is_negative r = ok c ∧\n    (c.val = 1#u8 ↔ (Field51_as_Nat r % p) % 2 = 1) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/IsNegative.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::is_negative",
   "nested_children": [],
   "lines": "L150-L153",
   "lean_name": "curve25519_dalek.field.FieldElement51.is_negative",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_zero_spec (r : backend.serial.u64.field.FieldElement51) :\n    ∃ c, is_zero r = ok c ∧\n    (c.val = 1#u8 ↔ Field51_as_Nat r % p = 0) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/IsZero.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::is_zero",
   "nested_children": [],
   "lines": "L160-L165",
   "lean_name": "curve25519_dalek.field.FieldElement51.is_zero",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem pow22501_spec (r : backend.serial.u64.field.FieldElement51) (h_bounds : ∀ i, i < 5 → (r[i]!).val < 2 ^ 54) :\n    ∃ r1 r2, pow22501 r = ok (r1, r2) ∧\n    Field51_as_Nat r1 % p = (Field51_as_Nat r ^ (2 ^ 250 - 1)) % p ∧\n    Field51_as_Nat r2 % p = (Field51_as_Nat r ^ 11) % p ∧\n    (∀ i, i < 5 → (r1[i]!).val < 2 ^ 52) ∧\n    (∀ i, i < 5 → (r2[i]!).val < 2 ^ 52)\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/Pow22501.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `field.FieldElement51.pow22501`**:\n- No panic (always returns (r1, r2) successfully)\n- Field51_as_Nat(r1) ≡ Field51_as_Nat(r)^(2^250-1) (mod p)\n  Field51_as_Nat(r2) ≡ Field51_as_Nat(r)^11 (mod p)\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow22501",
   "nested_children": [],
   "lines": "L170-L204",
   "lean_name": "curve25519_dalek.field.FieldElement51.pow22501",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem pow_p58_spec (r : backend.serial.u64.field.FieldElement51) (h_bounds : ∀ i, i < 5 → (r[i]!).val ≤ 2 ^ 52 - 1) :\n    ∃ r', pow_p58 r = ok r' ∧\n    Field51_as_Nat r' % p = (Field51_as_Nat r ^ (2 ^ 252 - 3)) % p ∧\n    (∀ i, i < 5 → (r'[i]!).val ≤ 2 ^ 52 - 1)\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/PowP58.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `field.FieldElement51.pow_p58`**:\n- No panic for field element inputs r (always returns r' successfully)\n- Field51_as_Nat(r') ≡ Field51_as_Nat(r)^(2^252-3) (mod p)\n-/",
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::pow_p58",
   "nested_children": ["curve25519_dalek.field.FieldElement51.pow_p58.match_1"],
   "lines": "L269-L278",
   "lean_name": "curve25519_dalek.field.FieldElement51.pow_p58",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.pow22501",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.pow2k",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem sqrt_ratio_i_spec\n    (u : backend.serial.u64.field.FieldElement51)\n    (v : backend.serial.u64.field.FieldElement51)\n    (h_u_bounds : ∀ i, i < 5 → (u[i]!).val ≤ 2 ^ 52 - 1)\n    (h_v_bounds : ∀ i, i < 5 → (v[i]!).val ≤ 2 ^ 52 - 1) :\n    ∃ c, sqrt_ratio_i u v = ok c ∧\n    let u_nat := Field51_as_Nat u % p\n    let v_nat := Field51_as_Nat v % p\n    let r_nat := Field51_as_Nat c.2 % p\n    let i_nat := Field51_as_Nat backend.serial.u64.constants.SQRT_M1 % p\n    -- Case 1: u is zero\n    (u_nat = 0 →\n    c.1.val = 1#u8 ∧ r_nat = 0 ∧\n    (∀ i < 5,  c.2[i]!.val ≤ 2 ^ 53 - 1)) ∧\n    -- Case 2: u is nonzero and v is zero\n    (u_nat ≠ 0 ∧ v_nat = 0 →\n    c.1.val = 0#u8 ∧ r_nat = 0 ∧\n    (∀ i < 5,  c.2[i]!.val ≤ 2 ^ 53 - 1)) ∧\n    -- Case 3: u and v are nonzero and u/v is a square\n    (u_nat ≠ 0 ∧ v_nat ≠ 0 ∧ (∃ x : Nat, (x^2 * v_nat) % p = u_nat) →\n    c.1.val = 1#u8 ∧ (r_nat ^ 2 * v_nat) % p = u_nat ∧\n    (∀ i < 5,  c.2[i]!.val ≤ 2 ^ 53 - 1)) ∧\n    -- Case 4: u and v are nonzero and u/v is not a square\n    (u_nat ≠ 0 ∧ v_nat ≠ 0 ∧ (¬(∃ x : Nat, (x^2 * v_nat) % p = u_nat)) →\n    c.1.val = 0#u8 ∧ (r_nat ^2 * v_nat) % p = (i_nat * u_nat) % p ∧\n    (∀ i < 5,  c.2[i]!.val ≤ 2 ^ 53 - 1))\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Field/FieldElement51/SqrtRatioi.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{curve25519_dalek::backend::serial::u64::field::FieldElement51}::sqrt_ratio_i",
   "nested_children": [],
   "lines": "L292-L338",
   "lean_name": "curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.field.FieldElement51.pow_p58",
    "curve25519_dalek.field.ConstantTimeEqFieldElement51.ct_eq",
    "curve25519_dalek.backend.serial.u64.field.NegShared0FieldElement51FieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
    "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign",
    "curve25519_dalek.field.FieldElement51.is_negative"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/field.rs",
   "rust_name":
   "curve25519_dalek::field::{core::cmp::PartialEq<curve25519_dalek::backend::serial::u64::field::FieldElement51> for curve25519_dalek::backend::serial::u64::field::FieldElement51}::eq",
   "nested_children": [],
   "lines": "L87-L89",
   "lean_name":
   "curve25519_dalek.field.PartialEqFieldElement51FieldElement51.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.field.ConstantTimeEqFieldElement51.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::clone::Clone for curve25519_dalek::montgomery::MontgomeryPoint}::clone",
   "nested_children": [],
   "lines": "L73-L73",
   "lean_name": "curve25519_dalek.montgomery.CloneMontgomeryPoint.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::clone::Clone for curve25519_dalek::montgomery::ProjectivePoint}::clone",
   "nested_children": [],
   "lines": "L288-L288",
   "lean_name": "curve25519_dalek.montgomery.CloneProjectivePoint.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConditionallySelectable for curve25519_dalek::montgomery::MontgomeryPoint}::conditional_select",
   "nested_children": [],
   "lines": "L88-L90",
   "lean_name":
   "curve25519_dalek.montgomery.ConditionallySelectableMontgomeryPoint.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConditionallySelectable for curve25519_dalek::montgomery::ProjectivePoint}::conditional_select",
   "nested_children": [],
   "lines": "L311-L320",
   "lean_name":
   "curve25519_dalek.montgomery.ConditionallySelectableProjectivePoint.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_select"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem ct_eq_spec (u v : MontgomeryPoint) :\n    ∃ c,\n    ct_eq u v = ok c ∧\n    (c = Choice.one ↔\n      (U8x32_as_Nat u % 2 ^ 255) ≡ (U8x32_as_Nat v % 2 ^ 255) [MOD p]) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/CtEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.ConstantTimeEqMontgomeryPoint.ct_eq`**:\n- No panic (always returns successfully)\n- Choice.one is returned iff the u-coordinates match modulo p\n- The comparison proceeds via `FieldElement51.from_bytes` and constant-time equality\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{subtle::ConstantTimeEq for curve25519_dalek::montgomery::MontgomeryPoint}::ct_eq",
   "nested_children": [],
   "lines": "L79-L84",
   "lean_name":
   "curve25519_dalek.montgomery.ConstantTimeEqMontgomeryPoint.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.field.ConstantTimeEqFieldElement51.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::default::Default for curve25519_dalek::montgomery::MontgomeryPoint}::default",
   "nested_children": [],
   "lines": "L73-L73",
   "lean_name": "curve25519_dalek.montgomery.DefaultMontgomeryPoint.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::default::Default for curve25519_dalek::montgomery::ProjectivePoint}::default",
   "nested_children": [],
   "lines": "L305-L307",
   "lean_name": "curve25519_dalek.montgomery.DefaultProjectivePoint.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.IdentityProjectivePoint.identity"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem identity_spec :\n    ∃ q, identity = ok q ∧\n    (∀ i : Fin 32, q[i]! = 0#u8) ∧\n    U8x32_as_Nat q = 0 := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Identity.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.IdentityMontgomeryPoint.identity`**:\n- No panic (always returns successfully)\n- The resulting MontgomeryPoint is 32 zero bytes\n- Interpreted as a natural number via `U8x32_as_Nat`, the result equals 0\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::MontgomeryPoint}::identity",
   "nested_children": [],
   "lines": "L114-L116",
   "lean_name": "curve25519_dalek.montgomery.IdentityMontgomeryPoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::ProjectivePoint}::identity",
   "nested_children": [],
   "lines": "L296-L301",
   "lean_name": "curve25519_dalek.montgomery.IdentityProjectivePoint.identity",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::as_bytes",
   "nested_children": [],
   "lines": "L199-L201",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_base_spec (scalar : scalar.Scalar) :\n    ∃ result,\n    mul_base scalar = ok result ∧\n    MontgomeryPoint.IsValid result ∧\n    (MontgomeryPoint.toPoint result).y = ((U8x32_as_Nat scalar.bytes) • constants.ED25519_BASEPOINT_POINT.toPoint).y\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulBase.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.mul_base`**:\n- No panic (always returns successfully)\n- Delegates to `edwards.EdwardsPoint.mul_base` and `edwards.EdwardsPoint.to_montgomery`\n- The returned MontgomeryPoint is the Montgomery conversion of the Edwards basepoint result\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::mul_base",
   "nested_children": [],
   "lines": "L128-L130",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.mul_base",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.mul_base",
    "curve25519_dalek.edwards.EdwardsPoint.to_montgomery"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_base_clamped_spec (bytes : Array U8 32#usize) :\n    ∃ result,\n    mul_base_clamped bytes = ok result ∧\n    MontgomeryPoint.IsValid result ∧\n    (MontgomeryPoint.toPoint result).y = ((U8x32_as_Nat bytes) • constants.ED25519_BASEPOINT_POINT.toPoint).y\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulBaseClamped.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.mul_base_clamped`**:\n- No panic (always returns successfully)\n- Clamps input bytes with `scalar.clamp_integer`\n- Delegates to `montgomery.MontgomeryPoint.mul_base` with the clamped scalar\n- The returned MontgomeryPoint matches the basepoint multiplication result\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::mul_base_clamped",
   "nested_children": [],
   "lines": "L150-L158",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.mul_base_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.montgomery.MontgomeryPoint.mul_base"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem mul_clamped_spec (P : MontgomeryPoint) (bytes : Array U8 32#usize)\n (h_is_valid : MontgomeryPoint.IsValid P) :\n    ∃ res,\n    mul_clamped P bytes = ok res ∧\n    MontgomeryPoint.IsValid res ∧\n    (MontgomeryPoint.toPoint res).y = ((U8x32_as_Nat bytes) • MontgomeryPoint.toPoint P).y\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulClamped.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.mul_clamped`**:\n- No panic (always returns successfully)\n- Clamps input bytes with `scalar.clamp_integer`\n- Delegates to `montgomery.MulScalarMontgomeryPointMontgomeryPoint.mul`\n- The returned MontgomeryPoint matches the clamped scalar multiplication result\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::mul_clamped",
   "nested_children": [],
   "lines": "L134-L146",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.mul_clamped",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.clamp_integer",
    "curve25519_dalek.montgomery.MulScalarMontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::to_bytes",
   "nested_children": [],
   "lines": "L204-L206",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem to_edwards_spec (mp : MontgomeryPoint) (sign : U8) :\n    ∃ opt_e,\n    to_edwards mp sign = ok opt_e ∧\n    let u := U8x32_as_Nat mp\n\n    ((u + 1) % p = 0 → opt_e = none) ∧\n\n    ((u + 1) % p ≠ 0 →\n      (opt_e = none ∨ -- can still return none if y cannot be decompressed into a valid Edwards point\n       ∃ e x_sign,\n       opt_e = some e ∧\n       field.FieldElement51.is_negative e.X = ok x_sign ∧\n       let y := Field51_as_Nat e.Y\n\n       y * (u + 1) % p = (u - 1) % p ∧\n       (x_sign.val = 1#u8 ↔ sign.val.testBit 0))) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/ToEdwards.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MontgomeryPoint.to_edwards`**:\n- Returns None if u ≡ -1 (mod p)\n- Returns None if the y-coordinate cannot be decompressed to a valid Edwards point\n- Otherwise, returns Some(EdwardsPoint) where:\n  - The y-coordinate satisfies: y * (u + 1) ≡ (u-1) (mod p)\n  - The sign of x matches the input sign parameter\nwhere p = 2^255 - 19\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::MontgomeryPoint}::to_edwards",
   "nested_children": [],
   "lines": "L224-L253",
   "lean_name": "curve25519_dalek.montgomery.MontgomeryPoint.to_edwards",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.field.PartialEqFieldElement51FieldElement51.eq",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.MINUS_ONE",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
    "curve25519_dalek.edwards.CompressedEdwardsY.decompress"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::montgomery::MontgomeryPoint}::mul_assign",
   "nested_children": [],
   "lines": "L118-L120",
   "lean_name":
   "curve25519_dalek.montgomery.MulAssignMontgomeryPointScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulAssignMontgomeryPointShared0Scalar.mul_assign"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem mul_assign_spec (P : MontgomeryPoint) (scalar : scalar.Scalar)\n    (h_is_valid : MontgomeryPoint.IsValid P) :\n    ∃ res,\n    mul_assign P scalar = ok res ∧\n    MontgomeryPoint.IsValid res ∧\n    (MontgomeryPoint.toPoint res).y = ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y ∧\n    let y : ZMod p  := ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y\n    bytesToField res =(1 + y) * (1 - y)⁻¹\n := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/MulAssign.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulAssignMontgomeryPointShared0Scalar.mul_assign`**:\n- No panic (always returns successfully)\n- Delegates to `montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul`\n- The returned MontgomeryPoint equals the Montgomery ladder result for the given scalar and point\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::MulAssign<&0 (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::montgomery::MontgomeryPoint}::mul_assign",
   "nested_children": [],
   "lines": "L454-L456",
   "lean_name":
   "curve25519_dalek.montgomery.MulAssignMontgomeryPointShared0Scalar.mul_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}::mul",
   "nested_children": [],
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.montgomery.MulMontgomeryPointScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem mul_spec (P : MontgomeryPoint) (rhs : scalar.Scalar)\n    (h_is_valid : MontgomeryPoint.IsValid P) :\n    ∃ res,\n    mul P rhs = ok res ∧\n    (MontgomeryPoint.IsValid res) ∧\n    (MontgomeryPoint.toPoint res).y = ((U8x32_as_Nat rhs.bytes) • (MontgomeryPoint.toPoint P)).y ∧\n    let y : ZMod p  := ((U8x32_as_Nat rhs.bytes) • (MontgomeryPoint.toPoint P)).y\n    bytesToField res =(1 + y) * (1 - y)⁻¹\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulMontgomeryPointSharedBScalarMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements scalar multiplication via delegation to the underlying operation\n- The result is mathematically equivalent to [scalar]point\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]point\n  * Mathematically equivalent to MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul\n  * If point has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]point), the u-coordinate of the n-fold sum of point on the Montgomery curve\n  * The Montgomery ladder maintains the invariant that x0 and x1 represent points\n    differing by point throughout the computation\n  * The computation maintains constant-time guarantees inherited from the underlying\n    Montgomery ladder implementation\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}::mul",
   "nested_children": [],
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.montgomery.MulMontgomeryPointSharedBScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem mul_spec (scalar : scalar.Scalar) (P : MontgomeryPoint)\n    (h_is_valid : MontgomeryPoint.IsValid P) :\n    ∃ res,\n    mul scalar P = ok res ∧\n    (MontgomeryPoint.IsValid res) ∧\n    (MontgomeryPoint.toPoint res).y = ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y ∧\n    let y : ZMod p  := ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y\n    bytesToField res =(1 + y) * (1 - y)⁻¹\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulScalarMontgomeryPointMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements scalar multiplication via delegation to the underlying operation\n- The result is mathematically equivalent to [scalar]point\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]point\n  * Mathematically equivalent to MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul\n  * If point has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]point), the u-coordinate of the n-fold sum of point on the Montgomery curve\n  * The Montgomery ladder maintains the invariant that x0 and x1 represent points\n    differing by point throughout the computation\n  * The computation maintains constant-time guarantees inherited from the underlying\n    Montgomery ladder implementation\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::montgomery::MontgomeryPoint, curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "nested_children": [],
   "lines": "L107-L109",
   "lean_name":
   "curve25519_dalek.montgomery.MulScalarMontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&'b (curve25519_dalek::montgomery::MontgomeryPoint), curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::scalar::Scalar}::mul",
   "nested_children": [],
   "lines": "L93-L95",
   "lean_name":
   "curve25519_dalek.montgomery.MulScalarSharedBMontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "\ntheorem mul_spec (P : MontgomeryPoint) (scalar : scalar.Scalar)\n    (h_is_valid : MontgomeryPoint.IsValid P) :\n    ∃ res,\n    mul P scalar = ok res ∧\n    (MontgomeryPoint.IsValid res) ∧\n    (MontgomeryPoint.toPoint res).y = ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y ∧\n    let y : ZMod p  := ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y\n    bytesToField res =(1 + y) * (1 - y)⁻¹\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements the Montgomery ladder for constant-time scalar multiplication\n- Processes scalar bits from bit 254 down to bit 0 using Algorithm 8 (Costello-Smith 2017)\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]P\n  * If P has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]P), the u-coordinate of the n-fold sum of P on the Montgomery curve\n  * The Montgomery ladder maintains the invariant that x0 and x1 represent points\n    differing by P throughout the computation\n  * When the scalar is reduced modulo the group order L, the result corresponds to\n    scalar multiplication in the prime-order subgroup\n  * The result is computed via projective arithmetic and converted back to affine form\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n  * The computation maintains constant-time guarantees: the sequence of operations\n    executed is independent of the scalar bit values (only conditional swaps and\n    unconditional arithmetic operations are performed)\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "nested_children":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul.match_1"],
   "lines": "L413-L450",
   "lean_name":
   "curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.montgomery.IdentityProjectivePoint.identity",
    "curve25519_dalek.scalar.Scalar.as_bytes",
    "curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul_loop",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.montgomery.ProjectivePoint.as_affine"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::scalar::Scalar), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "nested_children":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul_loop.mutual",
    "curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul_loop.match_1"],
   "lines": "L428-L433",
   "lean_name":
   "curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "\ntheorem mul_spec (scalar : scalar.Scalar) (P : MontgomeryPoint)\n     (h_is_valid : MontgomeryPoint.IsValid P) :\n    ∃ res,\n    mul scalar P = ok res ∧\n    (MontgomeryPoint.IsValid res) ∧\n    (MontgomeryPoint.toPoint res).y = ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y ∧\n    let y : ZMod p  := ((U8x32_as_Nat scalar.bytes) • (MontgomeryPoint.toPoint P)).y\n    bytesToField res =(1 + y) * (1 - y)⁻¹\n    :=by\n  unfold mul\n  progress*",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Mul.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul`**:\n- No panic (always returns successfully given valid inputs)\n- Implements scalar multiplication via delegation to the reverse operation\n- The result is mathematically equivalent to [scalar]point\n- Mathematical properties of the result:\n  * The result encodes the u-coordinate of the scalar multiplication [scalar]point\n  * Mathematically equivalent to MontgomeryPoint::mul with swapped arguments\n  * If point has u-coordinate u₀ and scalar is n (as an integer ≤ 2^255), then the result\n    encodes u₀([n]point), the u-coordinate of the n-fold sum of point on the Montgomery curve\n  * The computation maintains constant-time guarantees inherited from the underlying\n    Montgomery ladder implementation\n  * The returned MontgomeryPoint is a valid 32-byte encoding with value reduced modulo 2^255\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<&0 (curve25519_dalek::montgomery::MontgomeryPoint), curve25519_dalek::montgomery::MontgomeryPoint> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L462-L464",
   "lean_name":
   "curve25519_dalek.montgomery.MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::montgomery::MontgomeryPoint> for &'a (curve25519_dalek::montgomery::MontgomeryPoint)}::mul",
   "nested_children": [],
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.montgomery.MulSharedAMontgomeryPointScalarMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1MontgomeryPointShared0ScalarMontgomeryPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::ops::arith::Mul<curve25519_dalek::montgomery::MontgomeryPoint, curve25519_dalek::montgomery::MontgomeryPoint> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.montgomery.MulSharedAScalarMontgomeryPointMontgomeryPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.MulShared1ScalarShared0MontgomeryPointMontgomeryPoint.mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem eq_spec (u v : MontgomeryPoint) :\n    ∃ b,\n    eq u v = ok b ∧\n    (b = true ↔\n      (U8x32_as_Nat u % 2 ^ 255) ≡ (U8x32_as_Nat v % 2 ^ 255) [MOD p]) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/Eq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.PartialEqMontgomeryPointMontgomeryPoint.eq`**:\n- No panic (always returns successfully)\n- Returns true iff the u-coordinates are equal modulo p\n- Implemented via constant-time equality followed by Choice-to-Bool conversion\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{core::cmp::PartialEq<curve25519_dalek::montgomery::MontgomeryPoint> for curve25519_dalek::montgomery::MontgomeryPoint}::eq",
   "nested_children": [],
   "lines": "L94-L96",
   "lean_name":
   "curve25519_dalek.montgomery.PartialEqMontgomeryPointMontgomeryPoint.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.ConstantTimeEqMontgomeryPoint.ct_eq"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::montgomery::ProjectivePoint}::as_affine",
   "nested_children": [],
   "lines": "L330-L333",
   "lean_name": "curve25519_dalek.montgomery.ProjectivePoint.as_affine",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{zeroize::Zeroize for curve25519_dalek::montgomery::MontgomeryPoint}::zeroize",
   "nested_children": [],
   "lines": "L121-L123",
   "lean_name": "curve25519_dalek.montgomery.ZeroizeMontgomeryPoint.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem differential_add_and_double_spec\n    (P Q : montgomery.ProjectivePoint)\n    (affine_PmQ : backend.serial.u64.field.FieldElement51) :\n    ∃ (P' Q' : montgomery.ProjectivePoint),\n    montgomery.differential_add_and_double P Q affine_PmQ = ok (P', Q') := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Montgomery/MontgomeryPoint/DifferentialAddAndDouble.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `montgomery.differential_add_and_double`**:\n- No panic (always returns successfully)\n- Returns ([2]P, P+Q) as projective points\n- Implements the Montgomery ladder double-and-add operation\n-/",
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name": "curve25519_dalek::montgomery::differential_add_and_double",
   "nested_children": [],
   "lines": "L351-L389",
   "lean_name": "curve25519_dalek.montgomery.differential_add_and_double",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.APLUS2_OVER_FOUR"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name": "curve25519_dalek::montgomery::elligator_encode",
   "nested_children": [],
   "lines": "L263-L283",
   "lean_name": "curve25519_dalek.montgomery.elligator_encode",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square2",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.field.FieldElement51.invert",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A_NEG",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.constants.MONTGOMERY_A",
    "curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
    "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_select",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ZERO",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem add_spec (self other : RistrettoPoint)\n\n    (h_self_bounds : ∀ i < 5,\n      self.X[i]!.val < 2 ^ 53 ∧\n      self.Y[i]!.val < 2 ^ 53 ∧\n      self.Z[i]!.val < 2 ^ 53 ∧\n      self.T[i]!.val < 2 ^ 53)\n\n    (h_other_bounds : ∀ i < 5,\n      other.X[i]!.val < 2 ^ 53 ∧\n      other.Y[i]!.val < 2 ^ 53 ∧\n      other.Z[i]!.val < 2 ^ 53 ∧\n      other.T[i]!.val < 2 ^ 53)\n\n    (h_self_Z_nonzero : Field51_as_Nat self.Z % p ≠ 0)\n    (h_other_Z_nonzero : Field51_as_Nat other.Z % p ≠ 0) :\n\n    ∃ result, add self other = ok result ∧\n\n    (∀ i < 5,\n      result.X[i]!.val < 2 ^ 54  ∧\n      result.Y[i]!.val < 2 ^ 54  ∧\n      result.Z[i]!.val < 2 ^ 54  ∧\n      result.T[i]!.val < 2 ^ 54) ∧\n\n    let X₁ := Field51_as_Nat self.X\n    let Y₁ := Field51_as_Nat self.Y\n    let Z₁ := Field51_as_Nat self.Z\n    let T₁ := Field51_as_Nat self.T\n\n    let X₂ := Field51_as_Nat other.X\n    let Y₂ := Field51_as_Nat other.Y\n    let Z₂ := Field51_as_Nat other.Z\n    let T₂ := Field51_as_Nat other.T\n\n    let X₃ := Field51_as_Nat result.X\n    let Y₃ := Field51_as_Nat result.Y\n    let Z₃ := Field51_as_Nat result.Z\n    let T₃ := Field51_as_Nat result.T\n\n    X₃ % p = ((X₁ * Y₂ + Y₁ * X₂) * (Z₁ * Z₂ - d * T₁ * T₂)) % p ∧\n    Y₃ % p = ((Y₁ * Y₂ - a * X₁ * X₂) * (Z₁ * Z₂ + d * T₁ * T₂)) % p ∧\n    T₃ % p = ((Y₁ * Y₂ - a * X₁ * X₂) * (X₁ * Y₂ + Y₁ * X₂)) % p ∧\n    Z₃ % p = ((Z₁ * Z₂ - d * T₁ * T₂) * (Z₁ * Z₂ + d * T₁ * T₂)) % p := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Add.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.add`**:\n- No panic (always returns successfully)\n- Returns the sum P + Q (in elliptic curve addition) where P = self and Q = other\n- The resulting point's coordinates satisfy the twisted Edwards addition formulas modulo p\n  (see Section 3.1 in https://www.iacr.org/archive/asiacrypt2008/53500329/53500329.pdf)\n-/",
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for curve25519_dalek::ristretto::RistrettoPoint}::add",
   "nested_children": [],
   "lines": "L33-L35",
   "lean_name":
   "curve25519_dalek.ristretto.AddRistrettoPointRistrettoPointRistrettoPoint.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.AddShared0RistrettoPointSharedARistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Add<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::ristretto::RistrettoPoint)}::add",
   "nested_children": [],
   "lines": "L856-L858",
   "lean_name":
   "curve25519_dalek.ristretto.AddShared0RistrettoPointSharedARistrettoPointRistrettoPoint.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.AddEdwardsPointEdwardsPointEdwardsPoint.add"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (cr : CompressedRistretto) :\n    ∃ b, as_bytes cr = ok b ∧\n    b = cr := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.CompressedRistretto.as_bytes`**:\n- No panic (always returns successfully)\n- The result is the byte representation of the compressed Ristretto point\n- Since CompressedRistretto is defined as Array U8 32#usize, as_bytes is essentially the identity\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::as_bytes",
   "nested_children": [],
   "lines": "L236-L238",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem decompress_spec (comp : CompressedRistretto) :\n\n  ∃ result, decompress comp = ok result ∧\n\n  (¬comp.IsValid →\n    result = none) ∧\n\n  (comp.IsValid →\n    ∃ rist, result = some rist ∧ rist.IsValid) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/Decompress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.CompressedRistretto.decompress`**:\n- The function always succeeds for all U8x32 input arrays (no panic)\n- If the input is not valid, then the output is none\n- If the input is valid, then the output is a valid Ristretto point, i.e.,\n  it fulfils the Edwards point curve equation\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::decompress",
   "nested_children":
   ["curve25519_dalek.ristretto.CompressedRistretto.decompress.match_3",
    "curve25519_dalek.ristretto.CompressedRistretto.decompress.match_1"],
   "lines": "L257-L271",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.decompress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.decompress.step_1",
    "curve25519_dalek.ristretto.decompress.step_2"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (cr : CompressedRistretto) :\n    ∃ b, to_bytes cr = ok b ∧\n    b = cr := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/CompressedRistretto/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.CompressedRistretto.to_bytes`**:\n- No panic (always returns successfully)\n- The result is the byte representation of the compressed Ristretto point\n- Since CompressedRistretto is defined as Array U8 32#usize, to_bytes is essentially the identity\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::CompressedRistretto}::to_bytes",
   "nested_children": [],
   "lines": "L231-L233",
   "lean_name": "curve25519_dalek.ristretto.CompressedRistretto.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<&'a (curve25519_dalek::ristretto::RistrettoPoint), curve25519_dalek::ristretto::RistrettoPoint> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L944-L946",
   "lean_name":
   "curve25519_dalek.ristretto.MulShared0ScalarSharedARistrettoPointRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.MulSharedAScalarEdwardsPointEdwardsPoint.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{core::ops::arith::Mul<curve25519_dalek::ristretto::RistrettoPoint, curve25519_dalek::ristretto::RistrettoPoint> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L100-L102",
   "lean_name":
   "curve25519_dalek.ristretto.MulSharedAScalarRistrettoPointRistrettoPoint.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.MulShared0ScalarSharedARistrettoPointRistrettoPoint.mul"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem compress_spec\n  (rist1 rist2 : RistrettoPoint)\n  (h1_X_bounds : ∀ i, i < 5 → (rist1.X[i]!).val < 2 ^ 54)\n  (h1_Y_bounds : ∀ i, i < 5 → (rist1.Y[i]!).val < 2 ^ 53)\n  (h1_Z_bounds : ∀ i, i < 5 → (rist1.Z[i]!).val < 2 ^ 53)\n  (h1_T_bounds : ∀ i, i < 5 → (rist1.T[i]!).val < 2 ^ 54)\n  (h2_X_bounds : ∀ i, i < 5 → (rist2.X[i]!).val < 2 ^ 54)\n  (h2_Y_bounds : ∀ i, i < 5 → (rist2.Y[i]!).val < 2 ^ 53)\n  (h2_Z_bounds : ∀ i, i < 5 → (rist2.Z[i]!).val < 2 ^ 53)\n  (h2_T_bounds : ∀ i, i < 5 → (rist2.T[i]!).val < 2 ^ 54) :\n\n  ∃ c1,\n  ∃ c2,\n    compress rist1 = ok c1 ∧\n    compress rist2 = ok c2 ∧\n    ((∃ p1_times_8,\n      ∃ p2_times_8,\n      ∃ eq_choice,\n        edwards.EdwardsPoint.mul_by_cofactor rist1 = ok p1_times_8 ∧\n        edwards.EdwardsPoint.mul_by_cofactor rist2 = ok p2_times_8 ∧\n        edwards.ConstantTimeEqEdwardsPoint.ct_eq p1_times_8 p2_times_8 = ok eq_choice ∧\n        eq_choice = Choice.one) →\n      c1 = c2) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/Compress.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.compress`**:\n\n1. The function always succeeds (no panic) for all valid RistrettoPoint inputs\n2. Canonicalization: If two RistrettoPoint representations are equivalent\n  (i.e., their cofactor multiples are equal as Edwards points), then they compress to\n  the same byte representation.\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::compress",
   "nested_children": [],
   "lines": "L491-L524",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.compress",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.field.FieldElement51.invsqrt",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
    "curve25519_dalek.backend.serial.u64.constants.INVSQRT_A_MINUS_D",
    "curve25519_dalek.field.FieldElement51.is_negative",
    "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::coset4",
   "nested_children": [],
   "lines": "L641-L648",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.coset4",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.constants.EIGHT_TORSION",
    "curve25519_dalek.edwards.AddEdwardsPointEdwardsPointEdwardsPoint.add"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "theorem elligator_ristretto_flavor_spec\n  (r_0 : backend.serial.u64.field.FieldElement51)\n  (h_r_0_bounds : ∀ i, i < 5 → (r_0[i]!).val < 2 ^ 54) :\n  ∃ rist,\n    elligator_ristretto_flavor r_0 = ok rist ∧\n    rist.IsValid := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/ElligatorRistrettoFlavor.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.elligator_ristretto_flavor`**:\n• The function always succeeds (no panic) for all field element inputs\n• Given an input field element r₀, the output RistrettoPoint indeed lies on the Curve25519 Edwards curve, i.e.,\n  it indeed fulfils the curve equation.\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::elligator_ristretto_flavor",
   "nested_children": [],
   "lines": "L658-L694",
   "lean_name":
   "curve25519_dalek.ristretto.RistrettoPoint.elligator_ristretto_flavor",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_M1",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.constants.ONE_MINUS_EDWARDS_D_SQUARED",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.constants.MINUS_ONE",
    "curve25519_dalek.field.FieldElement51.sqrt_ratio_i",
    "curve25519_dalek.field.FieldElement51.is_negative",
    "curve25519_dalek.backend.serial.u64.field.ConditionallySelectableFieldElement51.conditional_assign",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D_MINUS_ONE_SQUARED",
    "curve25519_dalek.backend.serial.u64.constants.SQRT_AD_MINUS_ONE",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended"]},
  {"verified": false,
   "specified": true,
   "spec_statement":
   "\ntheorem from_uniform_bytes_spec (bytes : Array U8 64#usize) :\n    ∃ rist,\n    from_uniform_bytes bytes = ok rist ∧\n    rist.IsValid := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Ristretto/RistrettoPoint/FromUniformBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `ristretto.RistrettoPoint.from_uniform_bytes`**:\n- The function always succeeds (no panic)\n- The output is a mathematically valid Ristretto point\n-/",
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::from_uniform_bytes",
   "nested_children":
   ["curve25519_dalek.ristretto.RistrettoPoint.from_uniform_bytes.match_1"],
   "lines": "L789-L805",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.from_uniform_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.ristretto.RistrettoPoint.elligator_ristretto_flavor",
    "curve25519_dalek.ristretto.AddRistrettoPointRistrettoPointRistrettoPoint.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name":
   "curve25519_dalek::ristretto::{curve25519_dalek::ristretto::RistrettoPoint}::mul_base",
   "nested_children": [],
   "lines": "L954-L964",
   "lean_name": "curve25519_dalek.ristretto.RistrettoPoint.mul_base",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.MulSharedAScalarRistrettoPointRistrettoPoint.mul",
    "curve25519_dalek.constants.RISTRETTO_BASEPOINT_POINT"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name": "curve25519_dalek::ristretto::decompress::step_1",
   "nested_children": [],
   "lines": "L277-L295",
   "lean_name": "curve25519_dalek.ristretto.decompress.step_1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.ristretto.CompressedRistretto.as_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.from_bytes",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.to_bytes",
    "curve25519_dalek.field.FieldElement51.is_negative"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/ristretto.rs",
   "rust_name": "curve25519_dalek::ristretto::decompress::step_2",
   "nested_children": [],
   "lines": "L297-L335",
   "lean_name": "curve25519_dalek.ristretto.decompress.step_2",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.FieldElement51.square",
    "curve25519_dalek.backend.serial.u64.field.SubShared0FieldElement51SharedAFieldElement51FieldElement51.sub",
    "curve25519_dalek.backend.serial.u64.field.FieldElement51.ONE",
    "curve25519_dalek.backend.serial.u64.field.AddShared0FieldElement51SharedAFieldElement51FieldElement51.add",
    "curve25519_dalek.backend.serial.u64.field.NegShared0FieldElement51FieldElement51.neg",
    "curve25519_dalek.backend.serial.u64.constants.EDWARDS_D",
    "curve25519_dalek.backend.serial.u64.field.MulShared0FieldElement51SharedAFieldElement51FieldElement51.mul",
    "curve25519_dalek.field.FieldElement51.invsqrt",
    "curve25519_dalek.field.FieldElement51.is_negative",
    "curve25519_dalek.field.FieldElement51.is_zero"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::AddAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::add_assign",
   "nested_children": [],
   "lines": "L44-L46",
   "lean_name": "curve25519_dalek.scalar.AddAssignScalarScalar.add_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.AddAssignScalarSharedAScalar.add_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::AddAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}::add_assign",
   "nested_children": [],
   "lines": "L333-L335",
   "lean_name":
   "curve25519_dalek.scalar.AddAssignScalarSharedAScalar.add_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.AddScalarSharedBScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::add",
   "nested_children": [],
   "lines": "L33-L35",
   "lean_name": "curve25519_dalek.scalar.AddScalarScalarScalar.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.AddShared0ScalarSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::add",
   "nested_children": [],
   "lines": "L19-L21",
   "lean_name": "curve25519_dalek.scalar.AddScalarSharedBScalarScalar.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.AddShared0ScalarSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}::add",
   "nested_children": [],
   "lines": "L343-L347",
   "lean_name":
   "curve25519_dalek.scalar.AddShared0ScalarSharedAScalarScalar.add",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.add",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Add<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}::add",
   "nested_children": [],
   "lines": "L26-L28",
   "lean_name": "curve25519_dalek.scalar.AddSharedAScalarScalarScalar.add",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.AddShared0ScalarSharedAScalarScalar.add"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::clone::Clone for curve25519_dalek::scalar::Scalar}::clone",
   "nested_children": [],
   "lines": "L194-L194",
   "lean_name": "curve25519_dalek.scalar.CloneScalar.clone",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConditionallySelectable for curve25519_dalek::scalar::Scalar}::conditional_select",
   "nested_children": [],
   "lines": "L390-L397",
   "lean_name":
   "curve25519_dalek.scalar.ConditionallySelectableScalar.conditional_select",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.ConditionallySelectableScalar.conditional_select_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConditionallySelectable for curve25519_dalek::scalar::Scalar}::conditional_select",
   "nested_children": [],
   "lines": "L393-L395",
   "lean_name":
   "curve25519_dalek.scalar.ConditionallySelectableScalar.conditional_select_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ct_eq_spec (s s' : Scalar) :\n    ∃ c, ct_eq s s' = ok c ∧\n    (c = Choice.one ↔ s.bytes = s'.bytes) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/CtEq.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.ConstantTimeEqScalar.ct_eq`**:\n- No panic (always returns successfully)\n- Returns `Choice` representing equality in constant time\n- The result is Choice.one (true) if and only if the two scalars are equal (same byte representation)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{subtle::ConstantTimeEq for curve25519_dalek::scalar::Scalar}::ct_eq",
   "nested_children": [],
   "lines": "L301-L303",
   "lean_name": "curve25519_dalek.scalar.ConstantTimeEqScalar.ct_eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::default::Default for curve25519_dalek::scalar::Scalar}::default",
   "nested_children": [],
   "lines": "L487-L489",
   "lean_name": "curve25519_dalek.scalar.DefaultScalar.default",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.ZERO"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u128> for curve25519_dalek::scalar::Scalar}::from",
   "nested_children": [],
   "lines": "L549-L554",
   "lean_name": "curve25519_dalek.scalar.FromScalarU128.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u16> for curve25519_dalek::scalar::Scalar}::from",
   "nested_children": ["curve25519_dalek.scalar.FromScalarU16.from.match_1"],
   "lines": "L501-L506",
   "lean_name": "curve25519_dalek.scalar.FromScalarU16.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u32> for curve25519_dalek::scalar::Scalar}::from",
   "nested_children": [],
   "lines": "L510-L515",
   "lean_name": "curve25519_dalek.scalar.FromScalarU32.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u64> for curve25519_dalek::scalar::Scalar}::from",
   "nested_children": [],
   "lines": "L540-L545",
   "lean_name": "curve25519_dalek.scalar.FromScalarU64.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::convert::From<u8> for curve25519_dalek::scalar::Scalar}::from",
   "nested_children": [],
   "lines": "L493-L497",
   "lean_name": "curve25519_dalek.scalar.FromScalarU8.from",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::index::Index<usize, u8> for curve25519_dalek::scalar::Scalar}::index",
   "nested_children": [],
   "lines": "L310-L312",
   "lean_name": "curve25519_dalek.scalar.IndexScalarUsizeU8.index",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::MulAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::mul_assign",
   "nested_children": [],
   "lines": "L118-L120",
   "lean_name": "curve25519_dalek.scalar.MulAssignScalarScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.MulAssignScalarSharedAScalar.mul_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::MulAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}::mul_assign",
   "nested_children": [],
   "lines": "L316-L318",
   "lean_name":
   "curve25519_dalek.scalar.MulAssignScalarSharedAScalar.mul_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::mul",
   "nested_children": [],
   "lines": "L107-L109",
   "lean_name": "curve25519_dalek.scalar.MulScalarScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.MulShared0ScalarSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::mul",
   "nested_children": [],
   "lines": "L93-L95",
   "lean_name": "curve25519_dalek.scalar.MulScalarSharedBScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.MulShared0ScalarSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L325-L327",
   "lean_name":
   "curve25519_dalek.scalar.MulShared0ScalarSharedAScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Mul<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}::mul",
   "nested_children": [],
   "lines": "L100-L102",
   "lean_name": "curve25519_dalek.scalar.MulSharedAScalarScalarScalar.mul",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.MulShared0ScalarSharedAScalarScalar.mul"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Neg<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::neg",
   "nested_children": [],
   "lines": "L384-L386",
   "lean_name": "curve25519_dalek.scalar.NegScalarScalar.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.NegShared0ScalarScalar.neg"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Neg<curve25519_dalek::scalar::Scalar> for &0 (curve25519_dalek::scalar::Scalar)}::neg",
   "nested_children": [],
   "lines": "L375-L379",
   "lean_name": "curve25519_dalek.scalar.NegShared0ScalarScalar.neg",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.constants.R",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.ZERO",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::cmp::PartialEq<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::eq",
   "nested_children": [],
   "lines": "L295-L297",
   "lean_name": "curve25519_dalek.scalar.PartialEqScalarScalar.eq",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.ConstantTimeEqScalar.ct_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement": "theorem ONE_spec : U8x32_as_Nat ONE.bytes = 1 := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/One.lean",
   "spec_docstring":
   "/-- **Spec for `scalar.Scalar.ONE`**:\n\nThe ONE constant represents the scalar 1.\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ONE",
   "nested_children": [],
   "lines": "L569-L574",
   "lean_name": "curve25519_dalek.scalar.Scalar.ONE",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.ONE_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ONE",
   "nested_children": [],
   "lines": "L569-L574",
   "lean_name": "curve25519_dalek.scalar.Scalar.ONE_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem ZERO_spec : U8x32_as_Nat ZERO.bytes = 0 := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Zero.lean",
   "spec_docstring":
   "/-- **Spec for `scalar.Scalar.ZERO`**:\n\nThe ZERO constant represents the scalar 0.\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ZERO",
   "nested_children": [],
   "lines": "L566-L566",
   "lean_name": "curve25519_dalek.scalar.Scalar.ZERO",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.ZERO_body"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::ZERO",
   "nested_children": [],
   "lines": "L566-L566",
   "lean_name": "curve25519_dalek.scalar.Scalar.ZERO_body",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem as_bytes_spec (s : Scalar) :\n    ∃ b, as_bytes s = ok b ∧\n    b = s.bytes ∧ mk b = s := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/AsBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.as_bytes`**:\n- No panic (always returns successfully)\n- The result is the byte representation of the scalar (s.bytes)\n- Converting the result back to a Scalar via the constructor yields the original scalar\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_bytes",
   "nested_children": [],
   "lines": "L708-L710",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16",
   "nested_children":
   ["curve25519_dalek.scalar.Scalar.as_radix_16.top_half",
    "curve25519_dalek.scalar.Scalar.as_radix_16.bot_half"],
   "lines": "L998-L1034",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.IndexScalarUsizeU8.index",
    "curve25519_dalek.scalar.Scalar.as_radix_16_loop0",
    "curve25519_dalek.scalar.Scalar.as_radix_16_loop1"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16",
   "nested_children":
   ["curve25519_dalek.scalar.Scalar.as_radix_16_loop0._unsafe_rec"],
   "lines": "L1015-L1019",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16_loop0",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.IndexScalarUsizeU8.index"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::as_radix_16",
   "nested_children":
   ["curve25519_dalek.scalar.Scalar.as_radix_16_loop1._unsafe_rec"],
   "lines": "L1024-L1029",
   "lean_name": "curve25519_dalek.scalar.Scalar.as_radix_16_loop1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "nested_children": ["curve25519_dalek.scalar.Scalar.batch_invert.match_1"],
   "lines": "L790-L847",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.scalar.Scalar.ONE",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop0",
    "curve25519_dalek.scalar.Scalar52.pack",
    "curve25519_dalek.scalar.Scalar.ZERO",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop1",
    "curve25519_dalek.zeroize.ZeroizeScalar52"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "nested_children":
   ["curve25519_dalek.scalar.Scalar.batch_invert_loop0.mutual",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop0.match_3",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop0.match_1",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop0._unsafe_rec"],
   "lines": "L810-L820",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert_loop0",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::batch_invert",
   "nested_children":
   ["curve25519_dalek.scalar.Scalar.batch_invert_loop1.mutual",
    "curve25519_dalek.scalar.Scalar.batch_invert_loop1._unsafe_rec"],
   "lines": "L834-L841",
   "lean_name": "curve25519_dalek.scalar.Scalar.batch_invert_loop1",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_mod_order_spec (b : Array U8 32#usize) :\n    ∃ s, from_bytes_mod_order b = ok s ∧\n    U8x32_as_Nat s.bytes ≡ U8x32_as_Nat b [MOD L] ∧ U8x32_as_Nat s.bytes < L := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/FromBytesModOrder.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.from_bytes_mod_order`**:\n- No panic (always returns successfully)\n- The result scalar s, when converted to nat, equals the input bytes converted to nat modulo L\n- The result scalar s is less than L (the group order) -/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::from_bytes_mod_order",
   "nested_children": [],
   "lines": "L237-L246",
   "lean_name": "curve25519_dalek.scalar.Scalar.from_bytes_mod_order",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.reduce",
    "curve25519_dalek.scalar.IndexScalarUsizeU8.index"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_bytes_mod_order_wide_spec (b : Array U8 64#usize) :\n    ∃ s, from_bytes_mod_order_wide b = ok s ∧\n    U8x32_as_Nat s.bytes ≡ U8x64_as_Nat b [MOD L] ∧\n    U8x32_as_Nat s.bytes < L := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Scalar/Scalar/FromBytesModOrderWide.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.from_bytes_mod_order_wide`**:\n- No panic (always returns successfully)\n- The result scalar s, when converted to nat, equals the input bytes converted to nat modulo L\n- The result scalar s is less than L (the group order) -/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::from_bytes_mod_order_wide",
   "nested_children": [],
   "lines": "L250-L252",
   "lean_name": "curve25519_dalek.scalar.Scalar.from_bytes_mod_order_wide",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes_wide",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem from_canonical_bytes_spec (b : Array U8 32#usize) :\n    ∃ s, from_canonical_bytes b = ok s ∧\n    (U8x32_as_Nat b < L → s.is_some = Choice.one ∧ s.value.bytes = b) ∧\n    (L ≤ U8x32_as_Nat b → s.is_some = Choice.zero) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/FromCanonicalBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.from_canonical_bytes`**:\n- No panic (always returns successfully)\n- When the input bytes represent a canonical value (< L), the function returns a CtOption Scalar\n  where is_some = Choice.one and the scalar's byte representation equals the input bytes\n- When the input bytes represent a non-canonical value (≥ L), the function returns a CtOption Scalar\n  where is_some = Choice.zero (i.e., None)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::from_canonical_bytes",
   "nested_children": [],
   "lines": "L261-L265",
   "lean_name": "curve25519_dalek.scalar.Scalar.from_canonical_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.Scalar.is_canonical"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invert_spec (s : Scalar) (h : U8x32_as_Nat s.bytes % L ≠ 0) :\n    ∃ s', invert s = ok s' ∧\n    U8x32_as_Nat s.bytes * U8x32_as_Nat s'.bytes ≡ 1 [MOD L] := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Invert.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.invert`**:\n- Precondition: The input scalar s must be non-zero modulo L (inverting zero has undefined behavior)\n- No panic (returns successfully for non-zero input)\n- The result s' satisfies the multiplicative inverse property:\n  U8x32_as_Nat(s.bytes) * U8x32_as_Nat(s'.bytes) ≡ 1 (mod L)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::invert",
   "nested_children": [],
   "lines": "L749-L751",
   "lean_name": "curve25519_dalek.scalar.Scalar.invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.scalar.Scalar52.invert",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem is_canonical_spec (s : Scalar) :\n    ∃ c, is_canonical s = ok c ∧\n    (c = Choice.one ↔ U8x32_as_Nat s.bytes < L) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/IsCanonical.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.is_canonical`**:\n- No panic (always returns successfully)\n- Returns Choice.one if and only if the scalar's bytes represent a value less than L (the group order)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::is_canonical",
   "nested_children": [],
   "lines": "L1154-L1156",
   "lean_name": "curve25519_dalek.scalar.Scalar.is_canonical",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.reduce",
    "curve25519_dalek.scalar.ConstantTimeEqScalar.ct_eq"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem reduce_spec (s : Scalar) :\n    ∃ s',\n      reduce s = ok s' ∧\n      U8x32_as_Nat s'.bytes ≡ U8x32_as_Nat s.bytes [MOD L] ∧\n      U8x32_as_Nat s'.bytes < L\n := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Reduce.lean",
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::reduce",
   "nested_children": [],
   "lines": "L1145-L1150",
   "lean_name": "curve25519_dalek.scalar.Scalar.reduce",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.mul_internal",
    "curve25519_dalek.backend.serial.u64.constants.R",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_reduce",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem to_bytes_spec (s : Scalar) :\n    ∃ a, to_bytes s = ok a ∧\n    a = s.bytes ∧ mk a = s := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/ToBytes.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.to_bytes`**:\n- No panic (always returns successfully)\n- The result array a is the byte array representation of the scalar (s.bytes)\n- Converting the result a back to a Scalar via the constructor yields the original scalar s\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::to_bytes",
   "nested_children": [],
   "lines": "L693-L695",
   "lean_name": "curve25519_dalek.scalar.Scalar.to_bytes",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem unpack_spec (s : Scalar) :\n    ∃ u, unpack s = ok u ∧\n    Scalar52_as_Nat u = U8x32_as_Nat s.bytes ∧\n    (∀ i < 5, u[i]!.val < 2 ^ 62) := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/Scalar/Unpack.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar.unpack`**:\n- No panic (always returns successfully)\n- Packing the result back yields the original scalar: pack(u) = s\n- Both the packed s and the unpacked u represent the same natural number\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::scalar::Scalar}::unpack",
   "nested_children": [],
   "lines": "L1139-L1141",
   "lean_name": "curve25519_dalek.scalar.Scalar.unpack",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_bytes"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem invert_spec (u : Scalar52) (h : Scalar52_as_Nat u % L ≠ 0) (hu : ∀ i < 5, u[i]!.val < 2 ^ 62) :\n    ∃ u', invert u = ok u' ∧\n    (Scalar52_as_Nat u * Scalar52_as_Nat u') ≡ 1 [MOD L] := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Invert.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.invert`**:\n- Precondition: The unpacked input scalar u must be non-zero modulo L (inverting zero has undefined behavior)\n- No panic (returns successfully for non-zero input)\n- The result u' satisfies the multiplicative inverse property:\n  Scalar52_as_Nat(u) * Scalar52_as_Nat(u') ≡ 1 (mod L)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::invert",
   "nested_children": [],
   "lines": "L1228-L1230",
   "lean_name": "curve25519_dalek.scalar.Scalar52.invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.as_montgomery",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.from_montgomery"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem montgomery_invert_spec (u : Scalar52) (h : Scalar52_as_Nat u % L ≠ 0)\n    (h_bounds : ∀ i < 5, u[i]!.val < 2 ^ 62) :\n    ∃ u', montgomery_invert u = ok u' ∧\n    (Scalar52_as_Nat u * Scalar52_as_Nat u') % L = (R * R) % L ∧\n    (∀ i < 5, u'[i]!.val < 2 ^ 62) := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/MontgomeryInvert.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.montgomery_invert`**:\n- Precondition: u must be non-zero modulo L (i.e., represent a non-zero value in Montgomery form)\n- No panic (always returns successfully for non-zero inputs)\n- The result u' satisfies the property that Montgomery multiplication of u and u'\n  yields R mod L (the Montgomery representation of 1)\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::montgomery_invert",
   "nested_children":
   ["curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop._unsafe_rec",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply",
    "curve25519_dalek.scalar.Scalar52.montgomery_invert.square_multiply_loop.mutual"],
   "lines": "L1170-L1225",
   "lean_name": "curve25519_dalek.scalar.Scalar52.montgomery_invert",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_square",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.montgomery_mul"]},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem pack_spec (u : backend.serial.u64.scalar.Scalar52) :\n    ∃ s, pack u = ok s ∧\n    U8x32_as_Nat s.bytes ≡ Scalar52_as_Nat u [MOD L] ∧\n    U8x32_as_Nat s.bytes < L := by ...",
   "spec_file":
   "Curve25519Dalek/Specs/Backend/Serial/U64/Scalar/Scalar52/Pack.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.Scalar52.pack`**:\n- No panic (always returns successfully)\n- Both the unpacked r and the packed s represent the same natural number modulo L\n- The packed scalar is in canonical form (less than L) -/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{curve25519_dalek::backend::serial::u64::scalar::Scalar52}::pack",
   "nested_children": [],
   "lines": "L1161-L1165",
   "lean_name": "curve25519_dalek.scalar.Scalar52.pack",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.Scalar52.to_bytes"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::SubAssign<curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::sub_assign",
   "nested_children": [],
   "lines": "L81-L83",
   "lean_name": "curve25519_dalek.scalar.SubAssignScalarScalar.sub_assign",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.SubAssignScalarSharedAScalar.sub_assign"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::SubAssign<&'a (curve25519_dalek::scalar::Scalar)> for curve25519_dalek::scalar::Scalar}::sub_assign",
   "nested_children": [],
   "lines": "L353-L355",
   "lean_name":
   "curve25519_dalek.scalar.SubAssignScalarSharedAScalar.sub_assign",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.SubScalarSharedBScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::sub",
   "nested_children": [],
   "lines": "L70-L72",
   "lean_name": "curve25519_dalek.scalar.SubScalarScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.SubShared0ScalarSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<&'b (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for curve25519_dalek::scalar::Scalar}::sub",
   "nested_children": [],
   "lines": "L56-L58",
   "lean_name": "curve25519_dalek.scalar.SubScalarSharedBScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.SubShared0ScalarSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<&'a (curve25519_dalek::scalar::Scalar), curve25519_dalek::scalar::Scalar> for &1 (curve25519_dalek::scalar::Scalar)}::sub",
   "nested_children": [],
   "lines": "L363-L367",
   "lean_name":
   "curve25519_dalek.scalar.SubShared0ScalarSharedAScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.Scalar.unpack",
    "curve25519_dalek.backend.serial.u64.scalar.Scalar52.sub",
    "curve25519_dalek.scalar.Scalar52.pack"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/macros.rs",
   "rust_name":
   "curve25519_dalek::scalar::{core::ops::arith::Sub<curve25519_dalek::scalar::Scalar, curve25519_dalek::scalar::Scalar> for &'a (curve25519_dalek::scalar::Scalar)}::sub",
   "nested_children": [],
   "lines": "L63-L65",
   "lean_name": "curve25519_dalek.scalar.SubSharedAScalarScalarScalar.sub",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.scalar.SubShared0ScalarSharedAScalarScalar.sub"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{zeroize::Zeroize for curve25519_dalek::scalar::Scalar}::zeroize",
   "nested_children": [],
   "lines": "L559-L561",
   "lean_name": "curve25519_dalek.scalar.ZeroizeScalar.zeroize",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": true,
   "specified": true,
   "spec_statement":
   "theorem clamp_integer_spec (bytes : Array U8 32#usize) :\n    ∃ result, clamp_integer bytes = ok (result) ∧\n    h ∣ U8x32_as_Nat result ∧\n    U8x32_as_Nat result < 2^255 ∧\n    2^254 ≤ U8x32_as_Nat result := by ...",
   "spec_file": "Curve25519Dalek/Specs/Scalar/ClampInteger.lean",
   "spec_docstring":
   "/-- **Spec and proof concerning `scalar.clamp_integer`**:\n- No panic\n- (as_nat_32_u8 result) is divisible by h (cofactor of curve25519)\n- as_nat_32_u8 result < 2^255\n- 2^254 ≤ as_nat_32_u8 result\n-/",
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name": "curve25519_dalek::scalar::clamp_integer",
   "nested_children": [],
   "lines": "L1411-L1416",
   "lean_name": "curve25519_dalek.scalar.clamp_integer",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": true,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name": "curve25519_dalek::scalar::read_le_u64_into",
   "nested_children": [],
   "lines": "L1372-L1389",
   "lean_name": "curve25519_dalek.scalar.read_le_u64_into",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.read_le_u64_into_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name": "curve25519_dalek::scalar::read_le_u64_into",
   "nested_children":
   ["curve25519_dalek.scalar.read_le_u64_into_loop._unsafe_rec"],
   "lines": "L1375-L1388",
   "lean_name": "curve25519_dalek.scalar.read_le_u64_into_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "nested_children": [],
   "lines": "L257-L265",
   "lean_name": "curve25519_dalek.traits.IdentityAffineNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.IdentityAffineNielsPoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/edwards.rs",
   "rust_name":
   "curve25519_dalek::edwards::{curve25519_dalek::traits::Identity for curve25519_dalek::edwards::EdwardsPoint}",
   "nested_children": [],
   "lines": "L419-L428",
   "lean_name": "curve25519_dalek.traits.IdentityEdwardsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.edwards.IdentityEdwardsPoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{curve25519_dalek::traits::Identity for curve25519_dalek::montgomery::MontgomeryPoint}",
   "nested_children": [],
   "lines": "L112-L117",
   "lean_name": "curve25519_dalek.traits.IdentityMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.IdentityMontgomeryPoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::Identity for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "nested_children": [],
   "lines": "L240-L249",
   "lean_name": "curve25519_dalek.traits.IdentityProjectiveNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.IdentityProjectiveNielsPoint.identity"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/traits.rs",
   "rust_name":
   "curve25519_dalek::traits::{curve25519_dalek::traits::IsIdentity for T}",
   "nested_children":
   ["curve25519_dalek.traits.IsIdentity.Blanket.is_identity"],
   "lines": "L41-L48",
   "lean_name": "curve25519_dalek.traits.IsIdentity.Blanket",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{curve25519_dalek::traits::ValidityCheck for curve25519_dalek::backend::serial::curve_models::ProjectivePoint}",
   "nested_children": [],
   "lines": "L277-L290",
   "lean_name": "curve25519_dalek.traits.ValidityCheckProjectivePoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ValidityCheckProjectivePoint.is_valid"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_name":
   "curve25519_dalek::window::{core::convert::From<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::window::LookupTable<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint>}::from",
   "nested_children": [],
   "lines": "L98-L104",
   "lean_name":
   "curve25519_dalek.window.FromLookupTableProjectiveNielsPointSharedAEdwardsPoint.from",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.edwards.EdwardsPoint.as_projective_niels",
    "curve25519_dalek.window.FromLookupTableProjectiveNielsPointSharedAEdwardsPoint.from_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_name":
   "curve25519_dalek::window::{core::convert::From<&'a (curve25519_dalek::edwards::EdwardsPoint)> for curve25519_dalek::window::LookupTable<curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint>}::from",
   "nested_children":
   ["curve25519_dalek.window.FromLookupTableProjectiveNielsPointSharedAEdwardsPoint.from_loop.match_3",
    "curve25519_dalek.window.FromLookupTableProjectiveNielsPointSharedAEdwardsPoint.from_loop.match_1"],
   "lines": "L100-L137",
   "lean_name":
   "curve25519_dalek.window.FromLookupTableProjectiveNielsPointSharedAEdwardsPoint.from_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.AddShared0EdwardsPointSharedAProjectiveNielsPointCompletedPoint.add",
    "curve25519_dalek.backend.serial.curve_models.CompletedPoint.as_extended",
    "curve25519_dalek.edwards.EdwardsPoint.as_projective_niels"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_name":
   "curve25519_dalek::window::{curve25519_dalek::window::LookupTable<T>}::select",
   "nested_children": [],
   "lines": "L54-L76",
   "lean_name": "curve25519_dalek.window.LookupTable.select",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.window.LookupTable.select_loop"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/window.rs",
   "rust_name":
   "curve25519_dalek::window::{curve25519_dalek::window::LookupTable<T>}::select",
   "nested_children": [],
   "lines": "L64-L136",
   "lean_name": "curve25519_dalek.window.LookupTable.select_loop",
   "is_relevant": true,
   "is_hidden": false,
   "is_extraction_artifact": true,
   "fully_verified": false,
   "dependencies": []},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::AffineNielsPoint}",
   "nested_children": [],
   "lines": "L191-L197",
   "lean_name": "curve25519_dalek.zeroize.ZeroizeAffineNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ZeroizeAffineNielsPoint.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/field.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::field::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::field::FieldElement51}",
   "nested_children": [],
   "lines": "L52-L56",
   "lean_name": "curve25519_dalek.zeroize.ZeroizeFieldElement51",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.field.ZeroizeFieldElement51.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/montgomery.rs",
   "rust_name":
   "curve25519_dalek::montgomery::{zeroize::Zeroize for curve25519_dalek::montgomery::MontgomeryPoint}",
   "nested_children": [],
   "lines": "L120-L124",
   "lean_name": "curve25519_dalek.zeroize.ZeroizeMontgomeryPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.montgomery.ZeroizeMontgomeryPoint.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::curve_models::{zeroize::Zeroize for curve25519_dalek::backend::serial::curve_models::ProjectiveNielsPoint}",
   "nested_children": [],
   "lines": "L214-L221",
   "lean_name": "curve25519_dalek.zeroize.ZeroizeProjectiveNielsPoint",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.curve_models.ZeroizeProjectiveNielsPoint.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/scalar.rs",
   "rust_name":
   "curve25519_dalek::scalar::{zeroize::Zeroize for curve25519_dalek::scalar::Scalar}",
   "nested_children": [],
   "lines": "L558-L562",
   "lean_name": "curve25519_dalek.zeroize.ZeroizeScalar",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies": ["curve25519_dalek.scalar.ZeroizeScalar.zeroize"]},
  {"verified": false,
   "specified": false,
   "spec_statement": null,
   "spec_file": null,
   "spec_docstring": null,
   "source": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
   "rust_name":
   "curve25519_dalek::backend::serial::u64::scalar::{zeroize::Zeroize for curve25519_dalek::backend::serial::u64::scalar::Scalar52}",
   "nested_children": [],
   "lines": "L35-L39",
   "lean_name": "curve25519_dalek.zeroize.ZeroizeScalar52",
   "is_relevant": true,
   "is_hidden": true,
   "is_extraction_artifact": false,
   "fully_verified": false,
   "dependencies":
   ["curve25519_dalek.backend.serial.u64.scalar.ZeroizeScalar52.zeroize"]}]}